"use strict"; var DEFAULT_URL = "", DEFAULT_SCALE_DELTA = 1.1, MIN_SCALE = .25, MAX_SCALE = 10, SCALE_SELECT_CONTAINER_PADDING = 8, SCALE_SELECT_PADDING = 22, PAGE_NUMBER_LOADING_INDICATOR = "visiblePageIsLoading", DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5e3; PDFJS.imageResourcesPath = "/Content/PDF/web/images/", PDFJS.workerSrc = "/Content/PDF/build/pdf.worker.js", PDFJS.cMapUrl = "/Content/PDF/web/cmaps/", PDFJS.cMapPacked = !0; var mozL10n = document.mozL10n || document.webL10n, CSS_UNITS = 96 / 72, DEFAULT_SCALE_VALUE = "auto", DEFAULT_SCALE = 1, UNKNOWN_SCALE = 0, MAX_AUTO_SCALE = 1.25, SCROLLBAR_PADDING = 40, VERTICAL_PADDING = 5, CustomStyle = function () { var e = ["ms", "Moz", "Webkit", "O"], t = {}; function i() { } return i.getProp = function (i, n) { if (1 === arguments.length && "string" == typeof t[i]) return t[i]; var s, r, a = (n = n || document.documentElement).style; if ("string" == typeof a[i]) return t[i] = i; r = i.charAt(0).toUpperCase() + i.slice(1); for (var o = 0, d = e.length; o < d; o++) if ("string" == typeof a[s = e[o] + r]) return t[i] = s; return t[i] = "undefined" }, i.setProp = function (e, t, i) { var n = this.getProp(e); "undefined" !== n && (t.style[n] = i) }, i }(), NullCharactersRegExp = /\x00/g; function removeNullCharacters(e) { return e.replace(NullCharactersRegExp, "") } function getFileName(e) { var t = e.indexOf("#"), i = e.indexOf("?"), n = Math.min(t > 0 ? t : e.length, i > 0 ? i : e.length); return e.substring(e.lastIndexOf("/", n) + 1, n) } function getOutputScale(e) { var t = (window.devicePixelRatio || 1) / (e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1); return { sx: t, sy: t, scaled: 1 !== t } } function scrollIntoView(e, t, i) { var n = e.offsetParent; if (n) { for (var s = i || !1, r = e.offsetTop + e.clientTop, a = e.offsetLeft + e.clientLeft; n.clientHeight === n.scrollHeight || s && "hidden" === getComputedStyle(n).overflow;) if (n.dataset._scaleY && (r /= n.dataset._scaleY, a /= n.dataset._scaleX), r += n.offsetTop, a += n.offsetLeft, !(n = n.offsetParent)) return; t && (void 0 !== t.top && (r += t.top), void 0 !== t.left && (a += t.left, n.scrollLeft = a)), n.scrollTop = r } else console.error("offsetParent is not set -- cannot scroll") } function watchScroll(e, t) { var i = function (i) { s || (s = window.requestAnimationFrame(function () { s = null; var i = e.scrollTop, r = n.lastY; i !== r && (n.down = i > r), n.lastY = i, t(n) })) }, n = { down: !0, lastY: e.scrollTop, _eventHandler: i }, s = null; return e.addEventListener("scroll", i, !0), n } function parseQueryString(e) { for (var t = e.split("&"), i = {}, n = 0, s = t.length; n < s; ++n) { var r = t[n].split("="), a = r[0].toLowerCase(), o = r.length > 1 ? r[1] : null; i[decodeURIComponent(a)] = decodeURIComponent(o) } return i } function binarySearchFirstItem(e, t) { var i = 0, n = e.length - 1; if (0 === e.length || !t(e[n])) return e.length; if (t(e[i])) return i; for (; i < n;) { var s = i + n >> 1; t(e[s]) ? n = s : i = s + 1 } return i } function approximateFraction(e) { if (Math.floor(e) === e) return [e, 1]; var t = 1 / e; if (t > 8) return [1, 8]; if (Math.floor(t) === t) return [1, t]; for (var i = e > 1 ? t : e, n = 0, s = 1, r = 1, a = 1; ;) { var o = n + r, d = s + a; if (d > 8) break; i <= o / d ? (r = o, a = d) : (n = o, s = d) } return i - n / s < r / a - i ? i === e ? [n, s] : [s, n] : i === e ? [r, a] : [a, r] } function roundToDivide(e, t) { var i = e % t; return 0 === i ? e : Math.round(e - i + t) } function getVisibleElements(e, t, i) { var n = e.scrollTop, s = n + e.clientHeight, r = e.scrollLeft, a = r + e.clientWidth; for (var o, d, l, h, c, u, p = [], g = 0 === t.length ? 0 : binarySearchFirstItem(t, function (e) { var t = e.div; return t.offsetTop + t.clientTop + t.clientHeight > n }), f = t.length; g < f && (l = (d = (o = t[g]).div).offsetTop + d.clientTop, h = d.clientHeight, !(l > s)) ; g++) (u = d.offsetLeft + d.clientLeft) + d.clientWidth < r || u > a || (c = 100 * (h - (Math.max(0, n - l) + Math.max(0, l + h - s))) / h | 0, p.push({ id: o.id, x: u, y: l, view: o, percent: c })); var m = p[0], v = p[p.length - 1]; return i && p.sort(function (e, t) { var i = e.percent - t.percent; return Math.abs(i) > .001 ? -i : e.id - t.id }), { first: m, last: v, views: p } } function noContextMenuHandler(e) { e.preventDefault() } function getPDFFileNameFromURL(e) { var t = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i, i = /^(?:([^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(e), n = t.exec(i[1]) || t.exec(i[2]) || t.exec(i[3]); if (n && -1 !== (n = n[0]).indexOf("%")) try { n = t.exec(decodeURIComponent(n))[0] } catch (e) { } return n || "document.pdf" } var ProgressBar = function () { function e(e, t) { this.visible = !0, this.div = document.querySelector(e + " .progress"), this.bar = this.div.parentNode, this.height = t.height || 100, this.width = t.width || 100, this.units = t.units || "%", this.div.style.height = this.height + this.units, this.percent = 0 } return e.prototype = { updateBar: function () { if (this._indeterminate) return this.div.classList.add("indeterminate"), void (this.div.style.width = this.width + this.units); this.div.classList.remove("indeterminate"); var e = this.width * this._percent / 100; this.div.style.width = e + this.units }, get percent() { return this._percent }, set percent(e) { var t, i, n; this._indeterminate = isNaN(e), this._percent = (t = e, i = 0, n = 100, Math.min(Math.max(t, i), n)), this.updateBar() }, setWidth: function (e) { if (e) { var t = e.parentNode.offsetWidth - e.offsetWidth; t > 0 && this.bar.setAttribute("style", "width: calc(100% - " + t + "px);") } }, hide: function () { this.visible && (this.visible = !1, this.bar.classList.add("hidden"), document.body.classList.remove("loadingInProgress")) }, show: function () { this.visible || (this.visible = !0, document.body.classList.add("loadingInProgress"), this.bar.classList.remove("hidden")) } }, e }(), DEFAULT_PREFERENCES = { showPreviousViewOnLoad: !0, defaultZoomValue: "", sidebarViewOnLoad: 0, enableHandToolOnLoad: !1, enableWebGL: !1, pdfBugEnabled: !1, disableRange: !1, disableStream: !1, disableAutoFetch: !1, disableFontFace: !1, disableTextLayer: !1, useOnlyCssZoom: !1, externalLinkTarget: 0 }, SidebarView = { NONE: 0, THUMBS: 1, OUTLINE: 2, ATTACHMENTS: 3 }, Preferences = { prefs: Object.create(DEFAULT_PREFERENCES), isInitializedPromiseResolved: !1, initializedPromise: null, initialize: function () { return this.initializedPromise = this._readFromStorage(DEFAULT_PREFERENCES).then(function (e) { this.isInitializedPromiseResolved = !0, e && (this.prefs = e) }.bind(this)) }, _writeToStorage: function (e) { return Promise.resolve() }, _readFromStorage: function (e) { return Promise.resolve() }, reset: function () { return this.initializedPromise.then(function () { return this.prefs = Object.create(DEFAULT_PREFERENCES), this._writeToStorage(DEFAULT_PREFERENCES) }.bind(this)) }, reload: function () { return this.initializedPromise.then(function () { this._readFromStorage(DEFAULT_PREFERENCES).then(function (e) { e && (this.prefs = e) }.bind(this)) }.bind(this)) }, set: function (e, t) { return this.initializedPromise.then(function () { if (void 0 === DEFAULT_PREFERENCES[e]) throw new Error("preferencesSet: '" + e + "' is undefined."); if (void 0 === t) throw new Error("preferencesSet: no value is specified."); var i = typeof t, n = typeof DEFAULT_PREFERENCES[e]; if (i !== n) { if ("number" !== i || "string" !== n) throw new Error("Preferences_set: '" + t + "' is a \"" + i + '", expected "' + n + '".'); t = t.toString() } else if ("number" === i && (0 | t) !== t) throw new Error("Preferences_set: '" + t + '\' must be an "integer".'); return this.prefs[e] = t, this._writeToStorage(this.prefs) }.bind(this)) }, get: function (e) { return this.initializedPromise.then(function () { var t = DEFAULT_PREFERENCES[e]; if (void 0 === t) throw new Error("preferencesGet: '" + e + "' is undefined."); var i = this.prefs[e]; return void 0 !== i ? i : t }.bind(this)) } }; Preferences._writeToStorage = function (e) { return new Promise(function (t) { localStorage.setItem("pdfjs.preferences", JSON.stringify(e)), t() }) }, Preferences._readFromStorage = function (e) { return new Promise(function (e) { e(JSON.parse(localStorage.getItem("pdfjs.preferences"))) }) }, function () { if (!("mozPrintCallback" in document.createElement("canvas"))) { var e, t; HTMLCanvasElement.prototype.mozPrintCallback = void 0; var i = window.print; window.print = function () { if (e) console.warn("Ignored window.print() because of a pending print job."); else try { r("beforeprint") } finally { e = document.querySelectorAll("canvas"), t = -1, a() } }; var n = !!document.attachEvent; if (window.addEventListener("keydown", function (t) { if (80 === t.keyCode && (t.ctrlKey || t.metaKey) && !t.altKey && (!t.shiftKey || window.chrome || window.opera)) { if (window.print(), n) return; return t.preventDefault(), void (t.stopImmediatePropagation ? t.stopImmediatePropagation() : t.stopPropagation()) } 27 === t.keyCode && e && o() }, !0), n && document.attachEvent("onkeydown", function (e) { if (80 === (e = e || window.event).keyCode && e.ctrlKey) return e.keyCode = 0, !1 }), "onbeforeprint" in window) { var s = function (e) { "custom" !== e.detail && e.stopImmediatePropagation && e.stopImmediatePropagation() }; window.addEventListener("beforeprint", s, !1), window.addEventListener("afterprint", s, !1) } } function r(e) { var t = document.createEvent("CustomEvent"); t.initCustomEvent(e, !1, !1, "custom"), window.dispatchEvent(t) } function a() { if (e) if (d(), ++t < e.length) { var n = e[t]; "function" == typeof n.mozPrintCallback ? n.mozPrintCallback({ context: n.getContext("2d"), abort: o, done: a }) : a() } else d(), i.call(window), setTimeout(o, 20) } function o() { e && (e = null, d(), r("afterprint")) } function d() { var i = document.getElementById("mozPrintCallback-shim"); if (e && e.length) { var n = Math.round(100 * t / e.length), s = i.querySelector("progress"), r = i.querySelector(".relative-progress"); s.value = n, r.textContent = n + "%", i.removeAttribute("hidden"), i.onclick = o } else i.setAttribute("hidden", "") } }(); var DownloadManager = function () { function e(e, t) { var i = document.createElement("a"); if (i.click) i.href = e, i.target = "_parent", "download" in i && (i.download = t), (document.body || document.documentElement).appendChild(i), i.click(), i.parentNode.removeChild(i); else { if (window.top === window && e.split("#")[0] === window.location.href.split("#")[0]) { var n = -1 === e.indexOf("?") ? "?" : "&"; e = e.replace(/#|$/, n + "$&") } window.open(e, "_parent") } } function t() { } return t.prototype = { downloadUrl: function (t, i) { PDFJS.isValidUrl(t, !0) && e(t + "#pdfjs.action=download", i) }, downloadData: function (t, i, n) { if (navigator.msSaveBlob) return navigator.msSaveBlob(new Blob([t], { type: n }), i); e(PDFJS.createObjectURL(t, n), i) }, download: function (t, i, n) { URL ? navigator.msSaveBlob ? navigator.msSaveBlob(t, n) || this.downloadUrl(i, n) : e(URL.createObjectURL(t), n) : this.downloadUrl(i, n) } }, t }(), DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20, ViewHistory = function () { function e(e, t) { this.fingerprint = e, this.cacheSize = t || DEFAULT_VIEW_HISTORY_CACHE_SIZE, this.isInitializedPromiseResolved = !1, this.initializedPromise = this._readFromStorage().then(function (e) { this.isInitializedPromiseResolved = !0; var t, i = JSON.parse(e || "{}"); "files" in i || (i.files = []), i.files.length >= this.cacheSize && i.files.shift(); for (var n = 0, s = i.files.length; n < s; n++) { if (i.files[n].fingerprint === this.fingerprint) { t = n; break } } "number" != typeof t && (t = i.files.push({ fingerprint: this.fingerprint }) - 1), this.file = i.files[t], this.database = i }.bind(this)) } return e.prototype = { _writeToStorage: function () { return new Promise(function (e) { var t = JSON.stringify(this.database); localStorage.setItem("database", t), e() }.bind(this)) }, _readFromStorage: function () { return new Promise(function (e) { e(localStorage.getItem("database")) }) }, set: function (e, t) { if (this.isInitializedPromiseResolved) return this.file[e] = t, this._writeToStorage() }, setMultiple: function (e) { if (this.isInitializedPromiseResolved) { for (var t in e) this.file[t] = e[t]; return this._writeToStorage() } }, get: function (e, t) { return this.isInitializedPromiseResolved && this.file[e] || t } }, e }(), PDFFindBar = function () { function e(e) { if (this.opened = !1, this.bar = e.bar || null, this.toggleButton = e.toggleButton || null, this.findField = e.findField || null, this.highlightAll = e.highlightAllCheckbox || null, this.caseSensitive = e.caseSensitiveCheckbox || null, this.findMsg = e.findMsg || null, this.findResultsCount = e.findResultsCount || null, this.findStatusIcon = e.findStatusIcon || null, this.findPreviousButton = e.findPreviousButton || null, this.findNextButton = e.findNextButton || null, this.findController = e.findController || null, null === this.findController) throw new Error("PDFFindBar cannot be used without a PDFFindController instance."); var t = this; this.toggleButton.addEventListener("click", function () { t.toggle() }), this.findField.addEventListener("input", function () { t.dispatchEvent("") }), this.bar.addEventListener("keydown", function (e) { switch (e.keyCode) { case 13: e.target === t.findField && t.dispatchEvent("again", e.shiftKey); break; case 27: t.close() } }), this.findPreviousButton.addEventListener("click", function () { t.dispatchEvent("again", !0) }), this.findNextButton.addEventListener("click", function () { t.dispatchEvent("again", !1) }), this.highlightAll.addEventListener("click", function () { t.dispatchEvent("highlightallchange") }), this.caseSensitive.addEventListener("click", function () { t.dispatchEvent("casesensitivitychange") }) } return e.prototype = { dispatchEvent: function (e, t) { var i = document.createEvent("CustomEvent"); return i.initCustomEvent("find" + e, !0, !0, { query: this.findField.value, caseSensitive: this.caseSensitive.checked, highlightAll: this.highlightAll.checked, findPrevious: t }), window.dispatchEvent(i) }, updateUIState: function (e, t, i) { var n = !1, s = "", r = ""; switch (e) { case FindStates.FIND_FOUND: break; case FindStates.FIND_PENDING: r = "pending"; break; case FindStates.FIND_NOTFOUND: s = mozL10n.get("find_not_found", null, "Phrase not found"), n = !0; break; case FindStates.FIND_WRAPPED: s = t ? mozL10n.get("find_reached_top", null, "Reached top of document, continued from bottom") : mozL10n.get("find_reached_bottom", null, "Reached end of document, continued from top") } n ? this.findField.classList.add("notFound") : this.findField.classList.remove("notFound"), this.findField.setAttribute("data-status", r), this.findMsg.textContent = s, this.updateResultsCount(i) }, updateResultsCount: function (e) { this.findResultsCount && (e ? (this.findResultsCount.textContent = e.toLocaleString(), this.findResultsCount.classList.remove("hidden")) : this.findResultsCount.classList.add("hidden")) }, open: function () { this.opened || (this.opened = !0, this.toggleButton.classList.add("toggled"), this.bar.classList.remove("hidden")), this.findField.select(), this.findField.focus() }, close: function () { this.opened && (this.opened = !1, this.toggleButton.classList.remove("toggled"), this.bar.classList.add("hidden"), this.findController.active = !1) }, toggle: function () { this.opened ? this.close() : this.open() } }, e }(), FindStates = { FIND_FOUND: 0, FIND_NOTFOUND: 1, FIND_WRAPPED: 2, FIND_PENDING: 3 }, FIND_SCROLL_OFFSET_TOP = -50, FIND_SCROLL_OFFSET_LEFT = -400, PDFFindController = function () { function e(e) { this.startedTextExtraction = !1, this.extractTextPromises = [], this.pendingFindMatches = {}, this.active = !1, this.pageContents = [], this.pageMatches = [], this.matchCount = 0, this.selected = { pageIdx: -1, matchIdx: -1 }, this.offset = { pageIdx: null, matchIdx: null }, this.pagesToSearch = null, this.resumePageIdx = null, this.state = null, this.dirtyMatch = !1, this.findTimeout = null, this.pdfViewer = e.pdfViewer || null, this.integratedFind = e.integratedFind || !1, this.charactersToNormalize = { "‘": "'", "’": "'", "‚": "'", "‛": "'", "“": '"', "”": '"', "„": '"', "‟": '"', "¼": "1/4", "½": "1/2", "¾": "3/4", " ": " " }, this.findBar = e.findBar || null; var t = Object.keys(this.charactersToNormalize).join(""); this.normalizationRegex = new RegExp("[" + t + "]", "g"); var i = ["find", "findagain", "findhighlightallchange", "findcasesensitivitychange"]; this.firstPagePromise = new Promise(function (e) { this.resolveFirstPage = e }.bind(this)), this.handleEvent = this.handleEvent.bind(this); for (var n = 0, s = i.length; n < s; n++) window.addEventListener(i[n], this.handleEvent) } return e.prototype = { setFindBar: function (e) { this.findBar = e }, reset: function () { this.startedTextExtraction = !1, this.extractTextPromises = [], this.active = !1 }, normalize: function (e) { var t = this; return e.replace(this.normalizationRegex, function (e) { return t.charactersToNormalize[e] }) }, calcFindMatch: function (e) { var t = this.normalize(this.pageContents[e]), i = this.normalize(this.state.query), n = this.state.caseSensitive, s = i.length; if (0 !== s) { n || (t = t.toLowerCase(), i = i.toLowerCase()); for (var r = [], a = -s; -1 !== (a = t.indexOf(i, a + s)) ;) r.push(a); this.pageMatches[e] = r, this.updatePage(e), this.resumePageIdx === e && (this.resumePageIdx = null, this.nextPageMatch()), r.length > 0 && (this.matchCount += r.length, this.updateUIResultsCount()) } }, extractText: function () { if (!this.startedTextExtraction) { this.startedTextExtraction = !0, this.pageContents = []; for (var e = [], t = this.pdfViewer.pagesCount, i = 0; i < t; i++) this.extractTextPromises.push(new Promise(function (t) { e.push(t) })); var n = this; !function t(i) { n.pdfViewer.getPageTextContent(i).then(function (s) { for (var r = s.items, a = [], o = 0, d = r.length; o < d; o++) a.push(r[o].str); n.pageContents.push(a.join("")), e[i](i), i + 1 < n.pdfViewer.pagesCount && t(i + 1) }) }(0) } }, handleEvent: function (e) { null !== this.state && "findagain" === e.type || (this.dirtyMatch = !0), this.state = e.detail, this.updateUIState(FindStates.FIND_PENDING), this.firstPagePromise.then(function () { this.extractText(), clearTimeout(this.findTimeout), "find" === e.type ? this.findTimeout = setTimeout(this.nextMatch.bind(this), 250) : this.nextMatch() }.bind(this)) }, updatePage: function (e) { this.selected.pageIdx === e && this.pdfViewer.scrollPageIntoView(e + 1); var t = this.pdfViewer.getPageView(e); t.textLayer && t.textLayer.updateMatches() }, nextMatch: function () { var e = this.state.findPrevious, t = this.pdfViewer.currentPageNumber - 1, i = this.pdfViewer.pagesCount; if (this.active = !0, this.dirtyMatch) { this.dirtyMatch = !1, this.selected.pageIdx = this.selected.matchIdx = -1, this.offset.pageIdx = t, this.offset.matchIdx = null, this.hadMatch = !1, this.resumePageIdx = null, this.pageMatches = [], this.matchCount = 0; for (var n = this, s = 0; s < i; s++) this.updatePage(s), s in this.pendingFindMatches || (this.pendingFindMatches[s] = !0, this.extractTextPromises[s].then(function (e) { delete n.pendingFindMatches[e], n.calcFindMatch(e) })) } if ("" !== this.state.query) { if (!this.resumePageIdx) { var r = this.offset; if (this.pagesToSearch = i, null !== r.matchIdx) { var a = this.pageMatches[r.pageIdx].length; if (!e && r.matchIdx + 1 < a || e && r.matchIdx > 0) return this.hadMatch = !0, r.matchIdx = e ? r.matchIdx - 1 : r.matchIdx + 1, void this.updateMatch(!0); this.advanceOffsetPage(e) } this.nextPageMatch() } } else this.updateUIState(FindStates.FIND_FOUND) }, matchesReady: function (e) { var t = this.offset, i = e.length, n = this.state.findPrevious; return i ? (this.hadMatch = !0, t.matchIdx = n ? i - 1 : 0, this.updateMatch(!0), !0) : (this.advanceOffsetPage(n), !!(t.wrapped && (t.matchIdx = null, this.pagesToSearch < 0)) && (this.updateMatch(!1), !0)) }, updateMatchPosition: function (e, t, i, n, s) { if (this.selected.matchIdx === t && this.selected.pageIdx === e) { var r = { top: FIND_SCROLL_OFFSET_TOP, left: FIND_SCROLL_OFFSET_LEFT }; scrollIntoView(i[n], r, !0) } }, nextPageMatch: function () { null !== this.resumePageIdx && console.error("There can only be one pending page."); do { var e = this.offset.pageIdx, t = this.pageMatches[e]; if (!t) { this.resumePageIdx = e; break } } while (!this.matchesReady(t)) }, advanceOffsetPage: function (e) { var t = this.offset, i = this.extractTextPromises.length; t.pageIdx = e ? t.pageIdx - 1 : t.pageIdx + 1, t.matchIdx = null, this.pagesToSearch--, (t.pageIdx >= i || t.pageIdx < 0) && (t.pageIdx = e ? i - 1 : 0, t.wrapped = !0) }, updateMatch: function (e) { var t = FindStates.FIND_NOTFOUND, i = this.offset.wrapped; if (this.offset.wrapped = !1, e) { var n = this.selected.pageIdx; this.selected.pageIdx = this.offset.pageIdx, this.selected.matchIdx = this.offset.matchIdx, t = i ? FindStates.FIND_WRAPPED : FindStates.FIND_FOUND, -1 !== n && n !== this.selected.pageIdx && this.updatePage(n) } this.updateUIState(t, this.state.findPrevious), -1 !== this.selected.pageIdx && this.updatePage(this.selected.pageIdx) }, updateUIResultsCount: function () { if (null === this.findBar) throw new Error("PDFFindController is not initialized with a PDFFindBar instance."); this.findBar.updateResultsCount(this.matchCount) }, updateUIState: function (e, t) { if (this.integratedFind) FirefoxCom.request("updateFindControlState", { result: e, findPrevious: t }); else { if (null === this.findBar) throw new Error("PDFFindController is not initialized with a PDFFindBar instance."); this.findBar.updateUIState(e, t, this.matchCount) } } }, e }(), PDFLinkService = function () { function e() { this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null, this._pagesRefCache = null } return e.prototype = { setDocument: function (e, t) { this.baseUrl = t, this.pdfDocument = e, this._pagesRefCache = Object.create(null) }, setViewer: function (e) { this.pdfViewer = e }, setHistory: function (e) { this.pdfHistory = e }, get pagesCount() { return this.pdfDocument.numPages }, get page() { return this.pdfViewer.currentPageNumber }, set page(e) { this.pdfViewer.currentPageNumber = e }, navigateTo: function (e) { var t, i = "", n = this, s = function (t) { var r = t instanceof Object ? n._pagesRefCache[t.num + " " + t.gen + " R"] : t + 1; r ? (r > n.pagesCount && (r = n.pagesCount), n.pdfViewer.scrollPageIntoView(r, e), n.pdfHistory && n.pdfHistory.push({ dest: e, hash: i, page: r })) : n.pdfDocument.getPageIndex(t).then(function (e) { var i = e + 1, r = t.num + " " + t.gen + " R"; n._pagesRefCache[r] = i, s(t) }) }; "string" == typeof e ? (i = e, t = this.pdfDocument.getDestination(e)) : t = Promise.resolve(e), t.then(function (t) { e = t, t instanceof Array && s(t[0]) }) }, getDestinationHash: function (e) { if ("string" == typeof e) return this.getAnchorUrl("#" + escape(e)); if (e instanceof Array) { var t = e[0], i = t instanceof Object ? this._pagesRefCache[t.num + " " + t.gen + " R"] : t + 1; if (i) { var n = this.getAnchorUrl("#page=" + i), s = e[1]; if ("object" == typeof s && "name" in s && "XYZ" === s.name) { var r = e[4] || this.pdfViewer.currentScaleValue, a = parseFloat(r); a && (r = 100 * a), n += "&zoom=" + r, (e[2] || e[3]) && (n += "," + (e[2] || 0) + "," + (e[3] || 0)) } return n } } return "" }, getAnchorUrl: function (e) { return (this.baseUrl || "") + e }, setHash: function (e) { if (e.indexOf("=") >= 0) { var t, i, n = parseQueryString(e); if ("nameddest" in n) return this.pdfHistory && this.pdfHistory.updateNextHashParam(n.nameddest), void this.navigateTo(n.nameddest); if ("page" in n && (t = 0 | n.page || 1), "zoom" in n) { var s = n.zoom.split(","), r = s[0], a = parseFloat(r); -1 === r.indexOf("Fit") ? i = [null, { name: "XYZ" }, s.length > 1 ? 0 | s[1] : null, s.length > 2 ? 0 | s[2] : null, a ? a / 100 : r] : "Fit" === r || "FitB" === r ? i = [null, { name: r }] : "FitH" === r || "FitBH" === r || "FitV" === r || "FitBV" === r ? i = [null, { name: r }, s.length > 1 ? 0 | s[1] : null] : "FitR" === r ? 5 !== s.length ? console.error("PDFLinkService_setHash: Not enough parameters for 'FitR'.") : i = [null, { name: r }, 0 | s[1], 0 | s[2], 0 | s[3], 0 | s[4]] : console.error("PDFLinkService_setHash: '" + r + "' is not a valid zoom value.") } if (i ? this.pdfViewer.scrollPageIntoView(t || this.page, i) : t && (this.page = t), "pagemode" in n) { var o = document.createEvent("CustomEvent"); o.initCustomEvent("pagemode", !0, !0, { mode: n.pagemode }), this.pdfViewer.container.dispatchEvent(o) } } else /^\d+$/.test(e) ? this.page = e : (this.pdfHistory && this.pdfHistory.updateNextHashParam(unescape(e)), this.navigateTo(unescape(e))) }, executeNamedAction: function (e) { switch (e) { case "GoBack": this.pdfHistory && this.pdfHistory.back(); break; case "GoForward": this.pdfHistory && this.pdfHistory.forward(); break; case "NextPage": this.page++; break; case "PrevPage": this.page--; break; case "LastPage": this.page = this.pagesCount; break; case "FirstPage": this.page = 1 } var t = document.createEvent("CustomEvent"); t.initCustomEvent("namedaction", !0, !0, { action: e }), this.pdfViewer.container.dispatchEvent(t) }, cachePageRef: function (e, t) { var i = t.num + " " + t.gen + " R"; this._pagesRefCache[i] = e } }, e }(), PDFHistory = function () { function e(e) { this.linkService = e.linkService, this.initialized = !1, this.initialDestination = null, this.initialBookmark = null } return e.prototype = { initialize: function (e) { this.initialized = !0, this.reInitialized = !1, this.allowHashChange = !0, this.historyUnlocked = !0, this.isViewerInPresentationMode = !1, this.previousHash = window.location.hash.substring(1), this.currentBookmark = "", this.currentPage = 0, this.updatePreviousBookmark = !1, this.previousBookmark = "", this.previousPage = 0, this.nextHashParam = "", this.fingerprint = e, this.currentUid = this.uid = 0, this.current = {}; var t = window.history.state; this._isStateObjectDefined(t) ? (t.target.dest ? this.initialDestination = t.target.dest : this.initialBookmark = t.target.hash, this.currentUid = t.uid, this.uid = t.uid + 1, this.current = t.target) : (t && t.fingerprint && this.fingerprint !== t.fingerprint && (this.reInitialized = !0), this._pushOrReplaceState({ fingerprint: this.fingerprint }, !0)); var i = this; function n() { i.previousHash = window.location.hash.slice(1), i._pushToHistory({ hash: i.previousHash }, !1, !0), i._updatePreviousBookmark() } function s() { var e = i._getPreviousParams(null, !0); if (e) { var t = !i.current.dest && i.current.hash !== i.previousHash; i._pushToHistory(e, !1, t), i._updatePreviousBookmark() } window.removeEventListener("beforeunload", s, !1) } window.addEventListener("popstate", function (e) { i.historyUnlocked && (e.state ? i._goTo(e.state) : 0 === i.uid ? function (e, t) { function n() { window.removeEventListener("popstate", n), i.allowHashChange = !0, i.historyUnlocked = !0, t() } i.historyUnlocked = !1, i.allowHashChange = !1, window.addEventListener("popstate", function t() { window.removeEventListener("popstate", t); window.addEventListener("popstate", n); i._pushToHistory(e, !1, !0); history.forward() }), history.back() }(i.previousHash && i.currentBookmark && i.previousHash !== i.currentBookmark ? { hash: i.currentBookmark, page: i.currentPage } : { page: 1 }, function () { n() }) : n()) }, !1), window.addEventListener("beforeunload", s, !1), window.addEventListener("pageshow", function (e) { window.addEventListener("beforeunload", s, !1) }, !1), window.addEventListener("presentationmodechanged", function (e) { i.isViewerInPresentationMode = !!e.detail.active }) }, clearHistoryState: function () { this._pushOrReplaceState(null, !0) }, _isStateObjectDefined: function (e) { return !!(e && e.uid >= 0 && e.fingerprint && this.fingerprint === e.fingerprint && e.target && e.target.hash) }, _pushOrReplaceState: function (e, t) { t ? window.history.replaceState(e, "", document.URL) : window.history.pushState(e, "", document.URL) }, get isHashChangeUnlocked() { return !this.initialized || this.allowHashChange }, _updatePreviousBookmark: function () { this.updatePreviousBookmark && this.currentBookmark && this.currentPage && (this.previousBookmark = this.currentBookmark, this.previousPage = this.currentPage, this.updatePreviousBookmark = !1) }, updateCurrentBookmark: function (e, t) { this.initialized && (this.currentBookmark = e.substring(1), this.currentPage = 0 | t, this._updatePreviousBookmark()) }, updateNextHashParam: function (e) { this.initialized && (this.nextHashParam = e) }, push: function (e, t) { if (this.initialized && this.historyUnlocked) { if (e.dest && !e.hash && (e.hash = this.current.hash && this.current.dest && this.current.dest === e.dest ? this.current.hash : this.linkService.getDestinationHash(e.dest).split("#")[1]), e.page && (e.page |= 0), t) { var i = window.history.state.target; return i || (this._pushToHistory(e, !1), this.previousHash = window.location.hash.substring(1)), this.updatePreviousBookmark = !this.nextHashParam, void (i && this._updatePreviousBookmark()) } if (this.nextHashParam) { if (this.nextHashParam === e.hash) return this.nextHashParam = null, void (this.updatePreviousBookmark = !0); this.nextHashParam = null } e.hash ? this.current.hash ? this.current.hash !== e.hash ? this._pushToHistory(e, !0) : (!this.current.page && e.page && this._pushToHistory(e, !1, !0), this.updatePreviousBookmark = !0) : this._pushToHistory(e, !0) : this.current.page && e.page && this.current.page !== e.page && this._pushToHistory(e, !0) } }, _getPreviousParams: function (e, t) { if (!this.currentBookmark || !this.currentPage) return null; if (this.updatePreviousBookmark && (this.updatePreviousBookmark = !1), this.uid > 0 && (!this.previousBookmark || !this.previousPage)) return null; if (!this.current.dest && !e || t) { if (this.previousBookmark === this.currentBookmark) return null } else { if (!this.current.page && !e) return null; if (this.previousPage === this.currentPage) return null } var i = { hash: this.currentBookmark, page: this.currentPage }; return this.isViewerInPresentationMode && (i.hash = null), i }, _stateObj: function (e) { return { fingerprint: this.fingerprint, uid: this.uid, target: e } }, _pushToHistory: function (e, t, i) { if (this.initialized) { if (!e.hash && e.page && (e.hash = "page=" + e.page), t && !i) { var n = this._getPreviousParams(); if (n) { var s = !this.current.dest && this.current.hash !== this.previousHash; this._pushToHistory(n, !1, s) } } this._pushOrReplaceState(this._stateObj(e), i || 0 === this.uid), this.currentUid = this.uid++, this.current = e, this.updatePreviousBookmark = !0 } }, _goTo: function (e) { if (this.initialized && this.historyUnlocked && this._isStateObjectDefined(e)) { if (!this.reInitialized && e.uid < this.currentUid) { var t = this._getPreviousParams(!0); if (t) return this._pushToHistory(this.current, !1), this._pushToHistory(t, !1), this.currentUid = e.uid, void window.history.back() } this.historyUnlocked = !1, e.target.dest ? this.linkService.navigateTo(e.target.dest) : this.linkService.setHash(e.target.hash), this.currentUid = e.uid, e.uid > this.uid && (this.uid = e.uid), this.current = e.target, this.updatePreviousBookmark = !0; var i = window.location.hash.substring(1); this.previousHash !== i && (this.allowHashChange = !1), this.previousHash = i, this.historyUnlocked = !0 } }, back: function () { this.go(-1) }, forward: function () { this.go(1) }, go: function (e) { if (this.initialized && this.historyUnlocked) { var t = window.history.state; -1 === e && t && t.uid > 0 ? window.history.back() : 1 === e && t && t.uid < this.uid - 1 && window.history.forward() } } }, e }(), SecondaryToolbar = { opened: !1, previousContainerHeight: null, newContainerHeight: null, initialize: function (e) { this.toolbar = e.toolbar, this.buttonContainer = this.toolbar.firstElementChild, this.toggleButton = e.toggleButton, this.presentationModeButton = e.presentationModeButton, this.openFile = e.openFile, this.print = e.print, this.download = e.download, this.viewBookmark = e.viewBookmark, this.firstPage = e.firstPage, this.lastPage = e.lastPage, this.pageRotateCw = e.pageRotateCw, this.pageRotateCcw = e.pageRotateCcw, this.documentPropertiesButton = e.documentPropertiesButton; var t = [{ element: this.toggleButton, handler: this.toggle }, { element: this.presentationModeButton, handler: this.presentationModeClick }, { element: this.openFile, handler: this.openFileClick }, { element: this.print, handler: this.printClick }, { element: this.download, handler: this.downloadClick }, { element: this.viewBookmark, handler: this.viewBookmarkClick }, { element: this.firstPage, handler: this.firstPageClick }, { element: this.lastPage, handler: this.lastPageClick }, { element: this.pageRotateCw, handler: this.pageRotateCwClick }, { element: this.pageRotateCcw, handler: this.pageRotateCcwClick }, { element: this.documentPropertiesButton, handler: this.documentPropertiesClick }]; for (var i in t) { var n = t[i].element; n && n.addEventListener("click", t[i].handler.bind(this)) } }, presentationModeClick: function (e) { PDFViewerApplication.requestPresentationMode(), this.close() }, openFileClick: function (e) { document.getElementById("fileInput").click(), this.close() }, printClick: function (e) { window.print(), this.close() }, downloadClick: function (e) { PDFViewerApplication.download(), this.close() }, viewBookmarkClick: function (e) { this.close() }, firstPageClick: function (e) { PDFViewerApplication.page = 1, this.close() }, lastPageClick: function (e) { PDFViewerApplication.pdfDocument && (PDFViewerApplication.page = PDFViewerApplication.pagesCount), this.close() }, pageRotateCwClick: function (e) { PDFViewerApplication.rotatePages(90) }, pageRotateCcwClick: function (e) { PDFViewerApplication.rotatePages(-90) }, documentPropertiesClick: function (e) { PDFViewerApplication.pdfDocumentProperties.open(), this.close() }, setMaxHeight: function (e) { e && this.buttonContainer && (this.newContainerHeight = e.clientHeight, this.previousContainerHeight !== this.newContainerHeight && (this.buttonContainer.setAttribute("style", "max-height: " + (this.newContainerHeight - SCROLLBAR_PADDING) + "px;"), this.previousContainerHeight = this.newContainerHeight)) }, open: function () { this.opened || (this.opened = !0, this.toggleButton.classList.add("toggled"), this.toolbar.classList.remove("hidden")) }, close: function (e) { this.opened && (e && !this.toolbar.contains(e) || (this.opened = !1, this.toolbar.classList.add("hidden"), this.toggleButton.classList.remove("toggled"))) }, toggle: function () { this.opened ? this.close() : this.open() } }, DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1500, DELAY_BEFORE_HIDING_CONTROLS = 3e3, ACTIVE_SELECTOR = "pdfPresentationMode", CONTROLS_SELECTOR = "pdfPresentationModeControls", PDFPresentationMode = function () { function e(e) { this.container = e.container, this.viewer = e.viewer || e.container.firstElementChild, this.pdfViewer = e.pdfViewer, this.pdfThumbnailViewer = e.pdfThumbnailViewer || null; var t = e.contextMenuItems || null; if (this.active = !1, this.args = null, this.contextMenuOpen = !1, this.mouseScrollTimeStamp = 0, this.mouseScrollDelta = 0, t) for (var i = 0, n = t.length; i < n; i++) { var s = t[i]; s.element.addEventListener("click", function (e) { this.contextMenuOpen = !1, e() }.bind(this, s.handler)) } } return e.prototype = { request: function () { if (this.switchInProgress || this.active || !this.viewer.hasChildNodes()) return !1; if (this._addFullscreenChangeListeners(), this._setSwitchInProgress(), this._notifyStateChange(), this.container.requestFullscreen) this.container.requestFullscreen(); else if (this.container.mozRequestFullScreen) this.container.mozRequestFullScreen(); else if (this.container.webkitRequestFullscreen) this.container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT); else { if (!this.container.msRequestFullscreen) return !1; this.container.msRequestFullscreen() } return this.args = { page: this.pdfViewer.currentPageNumber, previousScale: this.pdfViewer.currentScaleValue }, !0 }, mouseScroll: function (e) { if (this.active) { var t = -1, i = 1, n = (new Date).getTime(), s = this.mouseScrollTimeStamp; if (!(n > s && n - s < 50) && ((this.mouseScrollDelta > 0 && e < 0 || this.mouseScrollDelta < 0 && e > 0) && this._resetMouseScrollState(), this.mouseScrollDelta += e, Math.abs(this.mouseScrollDelta) >= 120)) { var r = this.mouseScrollDelta > 0 ? t : i, a = this.pdfViewer.currentPageNumber; if (this._resetMouseScrollState(), 1 === a && r === t || a === this.pdfViewer.pagesCount && r === i) return; this.pdfViewer.currentPageNumber = a + r, this.mouseScrollTimeStamp = n } } }, get isFullscreen() { return !!(document.fullscreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement) }, _notifyStateChange: function () { var e = document.createEvent("CustomEvent"); e.initCustomEvent("presentationmodechanged", !0, !0, { active: this.active, switchInProgress: !!this.switchInProgress }), window.dispatchEvent(e) }, _setSwitchInProgress: function () { this.switchInProgress && clearTimeout(this.switchInProgress), this.switchInProgress = setTimeout(function () { this._removeFullscreenChangeListeners(), delete this.switchInProgress, this._notifyStateChange() }.bind(this), DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS) }, _resetSwitchInProgress: function () { this.switchInProgress && (clearTimeout(this.switchInProgress), delete this.switchInProgress) }, _enter: function () { this.active = !0, this._resetSwitchInProgress(), this._notifyStateChange(), this.container.classList.add(ACTIVE_SELECTOR), setTimeout(function () { this.pdfViewer.currentPageNumber = this.args.page, this.pdfViewer.currentScaleValue = "page-fit" }.bind(this), 0), this._addWindowListeners(), this._showControls(), this.contextMenuOpen = !1, this.container.setAttribute("contextmenu", "viewerContextMenu"), window.getSelection().removeAllRanges() }, _exit: function () { var e = this.pdfViewer.currentPageNumber; this.container.classList.remove(ACTIVE_SELECTOR), setTimeout(function () { this.active = !1, this._removeFullscreenChangeListeners(), this._notifyStateChange(), this.pdfViewer.currentScaleValue = this.args.previousScale, this.pdfViewer.currentPageNumber = e, this.args = null }.bind(this), 0), this._removeWindowListeners(), this._hideControls(), this._resetMouseScrollState(), this.container.removeAttribute("contextmenu"), this.contextMenuOpen = !1, this.pdfThumbnailViewer && this.pdfThumbnailViewer.ensureThumbnailVisible(e) }, _mouseDown: function (e) { if (this.contextMenuOpen) return this.contextMenuOpen = !1, void e.preventDefault(); 0 === e.button && (e.target.href && e.target.classList.contains("internalLink") || (e.preventDefault(), this.pdfViewer.currentPageNumber += e.shiftKey ? -1 : 1)) }, _contextMenu: function () { this.contextMenuOpen = !0 }, _showControls: function () { this.controlsTimeout ? clearTimeout(this.controlsTimeout) : this.container.classList.add(CONTROLS_SELECTOR), this.controlsTimeout = setTimeout(function () { this.container.classList.remove(CONTROLS_SELECTOR), delete this.controlsTimeout }.bind(this), DELAY_BEFORE_HIDING_CONTROLS) }, _hideControls: function () { this.controlsTimeout && (clearTimeout(this.controlsTimeout), this.container.classList.remove(CONTROLS_SELECTOR), delete this.controlsTimeout) }, _resetMouseScrollState: function () { this.mouseScrollTimeStamp = 0, this.mouseScrollDelta = 0 }, _addWindowListeners: function () { this.showControlsBind = this._showControls.bind(this), this.mouseDownBind = this._mouseDown.bind(this), this.resetMouseScrollStateBind = this._resetMouseScrollState.bind(this), this.contextMenuBind = this._contextMenu.bind(this), window.addEventListener("mousemove", this.showControlsBind), window.addEventListener("mousedown", this.mouseDownBind), window.addEventListener("keydown", this.resetMouseScrollStateBind), window.addEventListener("contextmenu", this.contextMenuBind) }, _removeWindowListeners: function () { window.removeEventListener("mousemove", this.showControlsBind), window.removeEventListener("mousedown", this.mouseDownBind), window.removeEventListener("keydown", this.resetMouseScrollStateBind), window.removeEventListener("contextmenu", this.contextMenuBind), delete this.showControlsBind, delete this.mouseDownBind, delete this.resetMouseScrollStateBind, delete this.contextMenuBind }, _fullscreenChange: function () { this.isFullscreen ? this._enter() : this._exit() }, _addFullscreenChangeListeners: function () { this.fullscreenChangeBind = this._fullscreenChange.bind(this), window.addEventListener("fullscreenchange", this.fullscreenChangeBind), window.addEventListener("mozfullscreenchange", this.fullscreenChangeBind), window.addEventListener("webkitfullscreenchange", this.fullscreenChangeBind), window.addEventListener("MSFullscreenChange", this.fullscreenChangeBind) }, _removeFullscreenChangeListeners: function () { window.removeEventListener("fullscreenchange", this.fullscreenChangeBind), window.removeEventListener("mozfullscreenchange", this.fullscreenChangeBind), window.removeEventListener("webkitfullscreenchange", this.fullscreenChangeBind), window.removeEventListener("MSFullscreenChange", this.fullscreenChangeBind), delete this.fullscreenChangeBind } }, e }(), GrabToPan = function () { function e(e) { this.element = e.element, this.document = e.element.ownerDocument, "function" == typeof e.ignoreTarget && (this.ignoreTarget = e.ignoreTarget), this.onActiveChanged = e.onActiveChanged, this.activate = this.activate.bind(this), this.deactivate = this.deactivate.bind(this), this.toggle = this.toggle.bind(this), this._onmousedown = this._onmousedown.bind(this), this._onmousemove = this._onmousemove.bind(this), this._endPan = this._endPan.bind(this), (this.overlay = document.createElement("div")).className = "grab-to-pan-grabbing" } var t; e.prototype = { CSS_CLASS_GRAB: "grab-to-pan-grab", activate: function () { this.active || (this.active = !0, this.element.addEventListener("mousedown", this._onmousedown, !0), this.element.classList.add(this.CSS_CLASS_GRAB), this.onActiveChanged && this.onActiveChanged(!0)) }, deactivate: function () { this.active && (this.active = !1, this.element.removeEventListener("mousedown", this._onmousedown, !0), this._endPan(), this.element.classList.remove(this.CSS_CLASS_GRAB), this.onActiveChanged && this.onActiveChanged(!1)) }, toggle: function () { this.active ? this.deactivate() : this.activate() }, ignoreTarget: function (e) { return e[t]("a[href], a[href] *, input, textarea, button, button *, select, option") }, _onmousedown: function (e) { if (0 === e.button && !this.ignoreTarget(e.target)) { if (e.originalTarget) try { e.originalTarget.tagName } catch (e) { return } this.scrollLeftStart = this.element.scrollLeft, this.scrollTopStart = this.element.scrollTop, this.clientXStart = e.clientX, this.clientYStart = e.clientY, this.document.addEventListener("mousemove", this._onmousemove, !0), this.document.addEventListener("mouseup", this._endPan, !0), this.element.addEventListener("scroll", this._endPan, !0), e.preventDefault(), e.stopPropagation(), this.document.documentElement.classList.add(this.CSS_CLASS_GRABBING); var t = document.activeElement; t && !t.contains(e.target) && t.blur() } }, _onmousemove: function (e) { if (this.element.removeEventListener("scroll", this._endPan, !0), function (e) { if ("buttons" in e && i) return !(1 | e.buttons); if (s || r) return 0 === e.which }(e)) this._endPan(); else { var t = e.clientX - this.clientXStart, n = e.clientY - this.clientYStart; this.element.scrollTop = this.scrollTopStart - n, this.element.scrollLeft = this.scrollLeftStart - t, this.overlay.parentNode || document.body.appendChild(this.overlay) } }, _endPan: function () { this.element.removeEventListener("scroll", this._endPan, !0), this.document.removeEventListener("mousemove", this._onmousemove, !0), this.document.removeEventListener("mouseup", this._endPan, !0), this.overlay.parentNode && this.overlay.parentNode.removeChild(this.overlay) } }, ["webkitM", "mozM", "msM", "oM", "m"].some(function (e) { var i = e + "atches"; return i in document.documentElement && (t = i), (i += "Selector") in document.documentElement && (t = i), t }); var i = !document.documentMode || document.documentMode > 9, n = window.chrome, s = n && (n.webstore || n.app), r = /Apple/.test(navigator.vendor) && /Version\/([6-9]\d*|[1-5]\d+)/.test(navigator.userAgent); return e }(), HandTool = { initialize: function (e) { var t = e.toggleHandTool; this.handTool = new GrabToPan({ element: e.container, onActiveChanged: function (e) { t && (e ? (t.title = mozL10n.get("hand_tool_disable.title", null, "Disable hand tool"), t.firstElementChild.textContent = mozL10n.get("hand_tool_disable_label", null, "Disable hand tool")) : (t.title = mozL10n.get("hand_tool_enable.title", null, "Enable hand tool"), t.firstElementChild.textContent = mozL10n.get("hand_tool_enable_label", null, "Enable hand tool"))) } }), t && (t.addEventListener("click", this.toggle.bind(this), !1), window.addEventListener("localized", function (e) { Preferences.get("enableHandToolOnLoad").then(function (e) { e && this.handTool.activate() }.bind(this), function (e) { }) }.bind(this)), window.addEventListener("presentationmodechanged", function (e) { e.detail.switchInProgress || (e.detail.active ? this.enterPresentationMode() : this.exitPresentationMode()) }.bind(this))) }, toggle: function () { this.handTool.toggle(), SecondaryToolbar.close() }, enterPresentationMode: function () { this.handTool.active && (this.wasActive = !0, this.handTool.deactivate()) }, exitPresentationMode: function () { this.wasActive && (this.wasActive = null, this.handTool.activate()) } }, OverlayManager = { overlays: {}, active: null, register: function (e, t, i) { return new Promise(function (n) { var s, r; if (!(e && (s = document.getElementById(e)) && (r = s.parentNode))) throw new Error("Not enough parameters."); if (this.overlays[e]) throw new Error("The overlay is already registered."); this.overlays[e] = { element: s, container: r, callerCloseMethod: t || null, canForceClose: i || !1 }, n() }.bind(this)) }, unregister: function (e) { return new Promise(function (t) { if (!this.overlays[e]) throw new Error("The overlay does not exist."); if (this.active === e) throw new Error("The overlay cannot be removed while it is active."); delete this.overlays[e], t() }.bind(this)) }, open: function (e) { return new Promise(function (t) { if (!this.overlays[e]) throw new Error("The overlay does not exist."); if (this.active) { if (!this.overlays[e].canForceClose) throw this.active === e ? new Error("The overlay is already active.") : new Error("Another overlay is currently active."); this._closeThroughCaller() } this.active = e, this.overlays[this.active].element.classList.remove("hidden"), this.overlays[this.active].container.classList.remove("hidden"), window.addEventListener("keydown", this._keyDown), t() }.bind(this)) }, close: function (e) { return new Promise(function (t) { if (!this.overlays[e]) throw new Error("The overlay does not exist."); if (!this.active) throw new Error("The overlay is currently not active."); if (this.active !== e) throw new Error("Another overlay is currently active."); this.overlays[this.active].container.classList.add("hidden"), this.overlays[this.active].element.classList.add("hidden"), this.active = null, window.removeEventListener("keydown", this._keyDown), t() }.bind(this)) }, _keyDown: function (e) { var t = OverlayManager; t.active && 27 === e.keyCode && (t._closeThroughCaller(), e.preventDefault()) }, _closeThroughCaller: function () { this.overlays[this.active].callerCloseMethod && this.overlays[this.active].callerCloseMethod(), this.active && this.close(this.active) } }, PasswordPrompt = { overlayName: null, updatePassword: null, reason: null, passwordField: null, passwordText: null, passwordSubmit: null, passwordCancel: null, initialize: function (e) { this.overlayName = e.overlayName, this.passwordField = e.passwordField, this.passwordText = e.passwordText, this.passwordSubmit = e.passwordSubmit, this.passwordCancel = e.passwordCancel, this.passwordSubmit.addEventListener("click", this.verifyPassword.bind(this)), this.passwordCancel.addEventListener("click", this.close.bind(this)), this.passwordField.addEventListener("keydown", function (e) { 13 === e.keyCode && this.verifyPassword() }.bind(this)), OverlayManager.register(this.overlayName, this.close.bind(this), !0) }, open: function () { OverlayManager.open(this.overlayName).then(function () { this.passwordField.focus(); var e = mozL10n.get("password_label", null, "Enter the password to open this PDF file."); this.reason === PDFJS.PasswordResponses.INCORRECT_PASSWORD && (e = mozL10n.get("password_invalid", null, "Invalid password. Please try again.")), this.passwordText.textContent = e }.bind(this)) }, close: function () { OverlayManager.close(this.overlayName).then(function () { this.passwordField.value = "" }.bind(this)) }, verifyPassword: function () { var e = this.passwordField.value; if (e && e.length > 0) return this.close(), this.updatePassword(e) } }, PDFDocumentProperties = function () { function e(e) { this.fields = e.fields, this.overlayName = e.overlayName, this.rawFileSize = 0, this.url = null, this.pdfDocument = null, e.closeButton && e.closeButton.addEventListener("click", this.close.bind(this)), this.dataAvailablePromise = new Promise(function (e) { this.resolveDataAvailable = e }.bind(this)), OverlayManager.register(this.overlayName, this.close.bind(this)) } return e.prototype = { open: function () { Promise.all([OverlayManager.open(this.overlayName), this.dataAvailablePromise]).then(function () { this._getProperties() }.bind(this)) }, close: function () { OverlayManager.close(this.overlayName) }, setFileSize: function (e) { e > 0 && (this.rawFileSize = e) }, setDocumentAndUrl: function (e, t) { this.pdfDocument = e, this.url = t, this.resolveDataAvailable() }, _getProperties: function () { OverlayManager.active && (this.pdfDocument.getDownloadInfo().then(function (e) { e.length !== this.rawFileSize && (this.setFileSize(e.length), this._updateUI(this.fields.fileSize, this._parseFileSize())) }.bind(this)), this.pdfDocument.getMetadata().then(function (e) { var t = { fileName: getPDFFileNameFromURL(this.url), fileSize: this._parseFileSize(), title: e.info.Title, author: e.info.Author, subject: e.info.Subject, keywords: e.info.Keywords, creationDate: this._parseDate(e.info.CreationDate), modificationDate: this._parseDate(e.info.ModDate), creator: e.info.Creator, producer: e.info.Producer, version: e.info.PDFFormatVersion, pageCount: this.pdfDocument.numPages }; for (var i in t) this._updateUI(this.fields[i], t[i]) }.bind(this))) }, _updateUI: function (e, t) { e && void 0 !== t && "" !== t && (e.textContent = t) }, _parseFileSize: function () { var e = this.rawFileSize, t = e / 1024; return t ? t < 1024 ? mozL10n.get("document_properties_kb", { size_kb: (+t.toPrecision(3)).toLocaleString(), size_b: e.toLocaleString() }, "{{size_kb}} KB ({{size_b}} bytes)") : mozL10n.get("document_properties_mb", { size_mb: (+(t / 1024).toPrecision(3)).toLocaleString(), size_b: e.toLocaleString() }, "{{size_mb}} MB ({{size_b}} bytes)") : void 0 }, _parseDate: function (e) { var t = e; if (void 0 === t) return ""; "D:" === t.substring(0, 2) && (t = t.substring(2)); var i = parseInt(t.substring(0, 4), 10), n = parseInt(t.substring(4, 6), 10) - 1, s = parseInt(t.substring(6, 8), 10), r = parseInt(t.substring(8, 10), 10), a = parseInt(t.substring(10, 12), 10), o = parseInt(t.substring(12, 14), 10), d = t.substring(14, 15), l = parseInt(t.substring(15, 17), 10), h = parseInt(t.substring(18, 20), 10); "-" === d ? (r += l, a += h) : "+" === d && (r -= l, a -= h); var c = new Date(Date.UTC(i, n, s, r, a, o)), u = c.toLocaleDateString(), p = c.toLocaleTimeString(); return mozL10n.get("document_properties_date_string", { date: u, time: p }, "{{date}}, {{time}}") } }, e }(), PresentationModeState = { UNKNOWN: 0, NORMAL: 1, CHANGING: 2, FULLSCREEN: 3 }, IGNORE_CURRENT_POSITION_ON_ZOOM = !1, DEFAULT_CACHE_SIZE = 10, CLEANUP_TIMEOUT = 3e4, RenderingStates = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 }, PDFRenderingQueue = function () { function e() { this.pdfViewer = null, this.pdfThumbnailViewer = null, this.onIdle = null, this.highestPriorityPage = null, this.idleTimeout = null, this.printing = !1, this.isThumbnailViewEnabled = !1 } return e.prototype = { setViewer: function (e) { this.pdfViewer = e }, setThumbnailViewer: function (e) { this.pdfThumbnailViewer = e }, isHighestPriority: function (e) { return this.highestPriorityPage === e.renderingId }, renderHighestPriority: function (e) { this.idleTimeout && (clearTimeout(this.idleTimeout), this.idleTimeout = null), this.pdfViewer.forceRendering(e) || this.pdfThumbnailViewer && this.isThumbnailViewEnabled && this.pdfThumbnailViewer.forceRendering() || this.printing || this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT)) }, getHighestPriority: function (e, t, i) { var n = e.views, s = n.length; if (0 === s) return !1; for (var r = 0; r < s; ++r) { var a = n[r].view; if (!this.isViewFinished(a)) return a } if (i) { var o = e.last.id; if (t[o] && !this.isViewFinished(t[o])) return t[o] } else { var d = e.first.id - 2; if (t[d] && !this.isViewFinished(t[d])) return t[d] } return null }, isViewFinished: function (e) { return e.renderingState === RenderingStates.FINISHED }, renderView: function (e) { switch (e.renderingState) { case RenderingStates.FINISHED: return !1; case RenderingStates.PAUSED: this.highestPriorityPage = e.renderingId, e.resume(); break; case RenderingStates.RUNNING: this.highestPriorityPage = e.renderingId; break; case RenderingStates.INITIAL: this.highestPriorityPage = e.renderingId; var t = function () { this.renderHighestPriority() }.bind(this); e.draw().then(t, t) } return !0 } }, e }(), TEXT_LAYER_RENDER_DELAY = 200, PDFPageView = function () { function e(e) { var t = e.container, i = e.id, n = e.scale, s = e.defaultViewport, r = e.renderingQueue, a = e.textLayerFactory, o = e.annotationsLayerFactory; this.id = i, this.renderingId = "page" + i, this.rotation = 0, this.scale = n || 1, this.viewport = s, this.pdfPageRotate = s.rotation, this.hasRestrictedScaling = !1, this.renderingQueue = r, this.textLayerFactory = a, this.annotationsLayerFactory = o, this.renderingState = RenderingStates.INITIAL, this.resume = null, this.onBeforeDraw = null, this.onAfterDraw = null, this.textLayer = null, this.zoomLayer = null, this.annotationLayer = null; var d = document.createElement("div"); d.id = "pageContainer" + this.id, d.className = "page", d.style.width = Math.floor(this.viewport.width) + "px", d.style.height = Math.floor(this.viewport.height) + "px", d.setAttribute("data-page-number", this.id), this.div = d, t.appendChild(d) } return e.prototype = { setPdfPage: function (e) { this.pdfPage = e, this.pdfPageRotate = e.rotate; var t = (this.rotation + this.pdfPageRotate) % 360; this.viewport = e.getViewport(this.scale * CSS_UNITS, t), this.stats = e.stats, this.reset() }, destroy: function () { this.zoomLayer = null, this.reset(), this.pdfPage && this.pdfPage.cleanup() }, reset: function (e, t) { this.renderTask && this.renderTask.cancel(), this.resume = null, this.renderingState = RenderingStates.INITIAL; var i = this.div; i.style.width = Math.floor(this.viewport.width) + "px", i.style.height = Math.floor(this.viewport.height) + "px"; for (var n = i.childNodes, s = e && this.zoomLayer || null, r = t && this.annotationLayer && this.annotationLayer.div || null, a = n.length - 1; a >= 0; a--) { var o = n[a]; s !== o && r !== o && i.removeChild(o) } i.removeAttribute("data-loaded"), r ? this.annotationLayer.hide() : this.annotationLayer = null, this.canvas && !s && (this.canvas.width = 0, this.canvas.height = 0, delete this.canvas), this.loadingIconDiv = document.createElement("div"), this.loadingIconDiv.className = "loadingIcon", i.appendChild(this.loadingIconDiv) }, update: function (e, t) { this.scale = e || this.scale, void 0 !== t && (this.rotation = t); var i = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: this.scale * CSS_UNITS, rotation: i }); var n = !1; if (this.canvas && PDFJS.maxCanvasPixels > 0) { var s = getOutputScale(this.canvas.getContext("2d")), r = this.viewport.width * this.viewport.height; Math.sqrt(PDFJS.maxCanvasPixels / r); (Math.floor(this.viewport.width) * s.sx | 0) * (Math.floor(this.viewport.height) * s.sy | 0) > PDFJS.maxCanvasPixels && (n = !0) } if (this.canvas) { if (PDFJS.useOnlyCssZoom || this.hasRestrictedScaling && n) { this.cssTransform(this.canvas, !0); var a = document.createEvent("CustomEvent"); return a.initCustomEvent("pagerendered", !0, !0, { pageNumber: this.id, cssTransform: !0 }), void this.div.dispatchEvent(a) } this.zoomLayer || (this.zoomLayer = this.canvas.parentNode, this.zoomLayer.style.position = "absolute") } this.zoomLayer && this.cssTransform(this.zoomLayer.firstChild), this.reset(!0, !0) }, updatePosition: function () { this.textLayer && this.textLayer.render(TEXT_LAYER_RENDER_DELAY) }, cssTransform: function (e, t) { var i = this.viewport.width, n = this.viewport.height, s = this.div; e.style.width = e.parentNode.style.width = s.style.width = Math.floor(i) + "px", e.style.height = e.parentNode.style.height = s.style.height = Math.floor(n) + "px"; var r = this.viewport.rotation - e._viewport.rotation, a = Math.abs(r), o = 1, d = 1; 90 !== a && 270 !== a || (o = n / i, d = i / n); var l = "rotate(" + r + "deg) scale(" + o + "," + d + ")"; if (CustomStyle.setProp("transform", e, l), this.textLayer) { var h = this.textLayer.viewport, c = this.viewport.rotation - h.rotation, u = Math.abs(c), p = i / h.width; 90 !== u && 270 !== u || (p = i / h.height); var g, f, m = this.textLayer.textLayerDiv; switch (u) { case 0: g = f = 0; break; case 90: g = 0, f = "-" + m.style.height; break; case 180: g = "-" + m.style.width, f = "-" + m.style.height; break; case 270: g = "-" + m.style.width, f = 0; break; default: console.error("Bad rotation value.") } CustomStyle.setProp("transform", m, "rotate(" + u + "deg) scale(" + p + ", " + p + ") translate(" + g + ", " + f + ")"), CustomStyle.setProp("transformOrigin", m, "0% 0%") } t && this.annotationLayer && this.annotationLayer.setupAnnotations(this.viewport) }, get width() { return this.viewport.width }, get height() { return this.viewport.height }, getPagePoint: function (e, t) { return this.viewport.convertToPdfPoint(e, t) }, draw: function () { this.renderingState !== RenderingStates.INITIAL && console.error("Must be in new state before drawing"), this.renderingState = RenderingStates.RUNNING; var e = this.pdfPage, t = this.viewport, i = this.div, n = document.createElement("div"); n.style.width = i.style.width, n.style.height = i.style.height, n.classList.add("canvasWrapper"); var s = document.createElement("canvas"); s.id = "page" + this.id, n.appendChild(s), this.annotationLayer && this.annotationLayer.div ? i.insertBefore(n, this.annotationLayer.div) : i.appendChild(n), this.canvas = s; var r = s.getContext("2d"), a = getOutputScale(r); if (PDFJS.useOnlyCssZoom) { var o = t.clone({ scale: CSS_UNITS }); a.sx *= o.width / t.width, a.sy *= o.height / t.height, a.scaled = !0 } if (PDFJS.maxCanvasPixels > 0) { var d = t.width * t.height, l = Math.sqrt(PDFJS.maxCanvasPixels / d); a.sx > l || a.sy > l ? (a.sx = l, a.sy = l, a.scaled = !0, this.hasRestrictedScaling = !0) : this.hasRestrictedScaling = !1 } var h = approximateFraction(a.sx), c = approximateFraction(a.sy); s.width = roundToDivide(t.width * a.sx, h[0]), s.height = roundToDivide(t.height * a.sy, c[0]), s.style.width = roundToDivide(t.width, h[1]) + "px", s.style.height = roundToDivide(t.height, c[1]) + "px", s._viewport = t; var u, p, g = null, f = null; this.textLayerFactory && ((g = document.createElement("div")).className = "textLayer", g.style.width = n.style.width, g.style.height = n.style.height, this.annotationLayer && this.annotationLayer.div ? i.insertBefore(g, this.annotationLayer.div) : i.appendChild(g), f = this.textLayerFactory.createTextLayerBuilder(g, this.id - 1, this.viewport)), this.textLayer = f, a.scaled && (r._transformMatrix = [a.sx, 0, 0, a.sy, 0, 0], r.scale(a.sx, a.sy)); var m = new Promise(function (e, t) { u = e, p = t }), v = this; function w(t) { if (S === v.renderTask && (v.renderTask = null), "cancelled" !== t) { if (v.renderingState = RenderingStates.FINISHED, v.loadingIconDiv && (i.removeChild(v.loadingIconDiv), delete v.loadingIconDiv), v.zoomLayer) { var n = v.zoomLayer.firstChild; n.width = 0, n.height = 0, i.removeChild(v.zoomLayer), v.zoomLayer = null } v.error = t, v.stats = e.stats, v.onAfterDraw && v.onAfterDraw(); var s = document.createEvent("CustomEvent"); s.initCustomEvent("pagerendered", !0, !0, { pageNumber: v.id, cssTransform: !1 }), i.dispatchEvent(s); var r = document.createEvent("CustomEvent"); r.initCustomEvent("pagerender", !0, !0, { pageNumber: e.pageNumber }), i.dispatchEvent(r), t ? p(t) : u(void 0) } else p(t) } var P = null; this.renderingQueue && (P = function (e) { if (!v.renderingQueue.isHighestPriority(v)) return v.renderingState = RenderingStates.PAUSED, void (v.resume = function () { v.renderingState = RenderingStates.RUNNING, e() }); e() }); var b = { canvasContext: r, viewport: this.viewport }, S = this.renderTask = this.pdfPage.render(b); return S.onContinue = P, this.renderTask.promise.then(function () { w(null), f && v.pdfPage.getTextContent().then(function (e) { f.setTextContent(e), f.render(TEXT_LAYER_RENDER_DELAY) }) }, function (e) { w(e) }), this.annotationsLayerFactory && (this.annotationLayer || (this.annotationLayer = this.annotationsLayerFactory.createAnnotationsLayerBuilder(i, this.pdfPage)), this.annotationLayer.setupAnnotations(this.viewport)), i.setAttribute("data-loaded", !0), v.onBeforeDraw && v.onBeforeDraw(), m }, beforePrint: function () { var e = this.pdfPage, t = e.getViewport(1), i = document.createElement("canvas"); i.width = 2 * Math.floor(t.width), i.height = 2 * Math.floor(t.height), i.style.width = "200%", i.style.height = "200%"; CustomStyle.setProp("transform", i, "scale(0.5, 0.5)"), CustomStyle.setProp("transformOrigin", i, "0% 0%"); var n = document.getElementById("printContainer"), s = document.createElement("div"); s.style.width = t.width + "pt", s.style.height = t.height + "pt", s.appendChild(i), n.appendChild(s), i.mozPrintCallback = function (n) { var s = n.context; s.save(), s.fillStyle = "rgb(255, 255, 255)", s.fillRect(0, 0, i.width, i.height), s.restore(), s._transformMatrix = [2, 0, 0, 2, 0, 0], s.scale(2, 2); var r = { canvasContext: s, viewport: t, intent: "print" }; e.render(r).promise.then(function () { n.done() }, function (e) { console.error(e), "abort" in n ? n.abort() : n.done() }) } } }, e }(), MAX_TEXT_DIVS_TO_RENDER = 1e5, NonWhitespaceRegexp = /\S/; function isAllWhitespace(e) { return !NonWhitespaceRegexp.test(e) } var TextLayerBuilder = function () { function e(e) { this.textLayerDiv = e.textLayerDiv, this.renderingDone = !1, this.divContentDone = !1, this.pageIdx = e.pageIndex, this.pageNumber = this.pageIdx + 1, this.matches = [], this.viewport = e.viewport, this.textDivs = [], this.findController = e.findController || null, this._bindMouse() } return e.prototype = { _finishRendering: function () { this.renderingDone = !0; var e = document.createElement("div"); e.className = "endOfContent", this.textLayerDiv.appendChild(e); var t = document.createEvent("CustomEvent"); t.initCustomEvent("textlayerrendered", !0, !0, { pageNumber: this.pageNumber }), this.textLayerDiv.dispatchEvent(t) }, renderLayer: function () { var e = document.createDocumentFragment(), t = this.textDivs, i = t.length, n = document.createElement("canvas").getContext("2d"); if (i > MAX_TEXT_DIVS_TO_RENDER) this._finishRendering(); else { for (var s, r, a = 0; a < i; a++) { var o = t[a]; if (void 0 === o.dataset.isWhitespace) { var d = o.style.fontSize, l = o.style.fontFamily; d === s && l === r || (n.font = d + " " + l, s = d, r = l); var h = n.measureText(o.textContent).width; if (h > 0) { var c; if (e.appendChild(o), void 0 !== o.dataset.canvasWidth) c = "scaleX(" + o.dataset.canvasWidth / h + ")"; else c = ""; var u = o.dataset.angle; u && (c = "rotate(" + u + "deg) " + c), c && CustomStyle.setProp("transform", o, c) } } } this.textLayerDiv.appendChild(e), this._finishRendering(), this.updateMatches() } }, render: function (e) { if (this.divContentDone && !this.renderingDone) if (this.renderTimer && (clearTimeout(this.renderTimer), this.renderTimer = null), e) { var t = this; this.renderTimer = setTimeout(function () { t.renderLayer(), t.renderTimer = null }, e) } else this.renderLayer() }, appendText: function (e, t) { var i = t[e.fontName], n = document.createElement("div"); if (this.textDivs.push(n), isAllWhitespace(e.str)) n.dataset.isWhitespace = !0; else { var s = PDFJS.Util.transform(this.viewport.transform, e.transform), r = Math.atan2(s[1], s[0]); i.vertical && (r += Math.PI / 2); var a, o, d = Math.sqrt(s[2] * s[2] + s[3] * s[3]), l = d; i.ascent ? l = i.ascent * l : i.descent && (l = (1 + i.descent) * l), 0 === r ? (a = s[4], o = s[5] - l) : (a = s[4] + l * Math.sin(r), o = s[5] - l * Math.cos(r)), n.style.left = a + "px", n.style.top = o + "px", n.style.fontSize = d + "px", n.style.fontFamily = i.fontFamily, n.textContent = e.str, PDFJS.pdfBug && (n.dataset.fontName = e.fontName), 0 !== r && (n.dataset.angle = r * (180 / Math.PI)), e.str.length > 1 && (i.vertical ? n.dataset.canvasWidth = e.height * this.viewport.scale : n.dataset.canvasWidth = e.width * this.viewport.scale) } }, setTextContent: function (e) { this.textContent = e; for (var t = e.items, i = 0, n = t.length; i < n; i++) this.appendText(t[i], e.styles); this.divContentDone = !0 }, convertMatches: function (e) { for (var t = 0, i = 0, n = this.textContent.items, s = n.length - 1, r = null === this.findController ? 0 : this.findController.state.query.length, a = [], o = 0, d = e.length; o < d; o++) { for (var l = e[o]; t !== s && l >= i + n[t].str.length;) i += n[t].str.length, t++; t === n.length && console.error("Could not find a matching mapping"); var h = { begin: { divIdx: t, offset: l - i } }; for (l += r; t !== s && l > i + n[t].str.length;) i += n[t].str.length, t++; h.end = { divIdx: t, offset: l - i }, a.push(h) } return a }, renderMatches: function (e) { if (0 !== e.length) { var t = this.textContent.items, i = this.textDivs, n = null, s = this.pageIdx, r = null !== this.findController && s === this.findController.selected.pageIdx, a = null === this.findController ? -1 : this.findController.selected.matchIdx, o = { divIdx: -1, offset: void 0 }, d = a, l = d + 1; if (null !== this.findController && this.findController.state.highlightAll) d = 0, l = e.length; else if (!r) return; for (var h = d; h < l; h++) { var c = e[h], u = c.begin, p = c.end, g = r && h === a ? " selected" : ""; if (this.findController && this.findController.updateMatchPosition(s, h, i, u.divIdx, p.divIdx), n && u.divIdx === n.divIdx ? w(n.divIdx, n.offset, u.offset) : (null !== n && w(n.divIdx, n.offset, o.offset), v(u)), u.divIdx === p.divIdx) w(u.divIdx, u.offset, p.offset, "highlight" + g); else { w(u.divIdx, u.offset, o.offset, "highlight begin" + g); for (var f = u.divIdx + 1, m = p.divIdx; f < m; f++) i[f].className = "highlight middle" + g; v(p, "highlight end" + g) } n = p } n && w(n.divIdx, n.offset, o.offset) } function v(e, t) { var n = e.divIdx; i[n].textContent = "", w(n, 0, e.offset, t) } function w(e, n, s, r) { var a = i[e], o = t[e].str.substring(n, s), d = document.createTextNode(o); if (r) { var l = document.createElement("span"); return l.className = r, l.appendChild(d), void a.appendChild(l) } a.appendChild(d) } }, updateMatches: function () { if (this.renderingDone) { for (var e = this.matches, t = this.textDivs, i = this.textContent.items, n = -1, s = 0, r = e.length; s < r; s++) { for (var a = e[s], o = Math.max(n, a.begin.divIdx), d = a.end.divIdx; o <= d; o++) { var l = t[o]; l.textContent = i[o].str, l.className = "" } n = a.end.divIdx + 1 } null !== this.findController && this.findController.active && (this.matches = this.convertMatches(null === this.findController ? [] : this.findController.pageMatches[this.pageIdx] || []), this.renderMatches(this.matches)) } }, _bindMouse: function () { var e = this.textLayerDiv; e.addEventListener("mousedown", function (t) { var i = e.querySelector(".endOfContent"); if (i) { var n = t.target !== e; if (n = n && "none" !== window.getComputedStyle(i).getPropertyValue("-moz-user-select")) { var s = e.getBoundingClientRect(), r = Math.max(0, (t.pageY - s.top) / s.height); i.style.top = (100 * r).toFixed(2) + "%" } i.classList.add("active") } }), e.addEventListener("mouseup", function (t) { var i = e.querySelector(".endOfContent"); i && (i.style.top = "", i.classList.remove("active")) }) } }, e }(); function DefaultTextLayerFactory() { } DefaultTextLayerFactory.prototype = { createTextLayerBuilder: function (e, t, i) { return new TextLayerBuilder({ textLayerDiv: e, pageIndex: t, viewport: i }) } }; var AnnotationsLayerBuilder = function () { function e(e) { this.pageDiv = e.pageDiv, this.pdfPage = e.pdfPage, this.linkService = e.linkService, this.div = null } return e.prototype = { setupAnnotations: function (e) { function t(e, t) { e.href = n.getDestinationHash(t), e.onclick = function () { return t && n.navigateTo(t), !1 }, t && (e.className = "internalLink") } function i(e, t) { e.href = n.getAnchorUrl(""), e.onclick = function () { return n.executeNamedAction(t), !1 }, e.className = "internalLink" } var n = this.linkService, s = this.pdfPage, r = this; s.getAnnotations().then(function (n) { var a, o, d, l, h = "matrix(" + (e = e.clone({ dontFlip: !0 })).transform.join(",") + ")"; if (r.div) { for (d = 0, l = n.length; d < l; d++) a = n[d], (o = r.div.querySelector('[data-annotation-id="' + a.id + '"]')) && CustomStyle.setProp("transform", o, h); r.div.removeAttribute("hidden") } else for (d = 0, l = n.length; d < l; d++) if ((a = n[d]) && a.hasHtml) { (o = PDFJS.AnnotationUtils.getHtmlElement(a, s.commonObjs)).setAttribute("data-annotation-id", a.id), void 0 !== mozL10n && mozL10n.translate(o); var c = a.rect, u = s.view; c = PDFJS.Util.normalizeRect([c[0], u[3] - c[1] + u[1], c[2], u[3] - c[3] + u[1]]), o.style.left = c[0] + "px", o.style.top = c[1] + "px", o.style.position = "absolute", CustomStyle.setProp("transform", o, h); var p = -c[0] + "px " + -c[1] + "px"; if (CustomStyle.setProp("transformOrigin", o, p), "Link" === a.subtype && !a.url) { var g = o.getElementsByTagName("a")[0]; g && (a.action ? i(g, a.action) : t(g, "dest" in a ? a.dest : null)) } if (!r.div) { var f = document.createElement("div"); f.className = "annotationLayer", r.pageDiv.appendChild(f), r.div = f } r.div.appendChild(o) } }) }, hide: function () { this.div && this.div.setAttribute("hidden", "true") } }, e }(); function DefaultAnnotationsLayerFactory() { } DefaultAnnotationsLayerFactory.prototype = { createAnnotationsLayerBuilder: function (e, t) { return new AnnotationsLayerBuilder({ pageDiv: e, pdfPage: t, linkService: new SimpleLinkService }) } }; var PDFViewer = function () { function e(e) { var t = []; this.push = function (i) { var n = t.indexOf(i); n >= 0 && t.splice(n, 1), t.push(i), t.length > e && t.shift().destroy() }, this.resize = function (i) { for (e = i; t.length > e;) t.shift().destroy() } } function t(e) { this.container = e.container, this.viewer = e.viewer || e.container.firstElementChild, this.linkService = e.linkService || new SimpleLinkService, this.removePageBorders = e.removePageBorders || !1, this.defaultRenderingQueue = !e.renderingQueue, this.defaultRenderingQueue ? (this.renderingQueue = new PDFRenderingQueue, this.renderingQueue.setViewer(this)) : this.renderingQueue = e.renderingQueue, this.scroll = watchScroll(this.container, this._scrollUpdate.bind(this)), this.updateInProgress = !1, this.presentationModeState = PresentationModeState.UNKNOWN, this._resetView(), this.removePageBorders && this.viewer.classList.add("removePageBorders") } return t.prototype = { get pagesCount() { return this._pages.length }, getPageView: function (e) { return this._pages[e] }, get currentPageNumber() { return this._currentPageNumber }, set currentPageNumber(e) { if (this.pdfDocument) { var t = document.createEvent("UIEvents"); if (t.initUIEvent("pagechange", !0, !0, window, 0), t.updateInProgress = this.updateInProgress, !(0 < e && e <= this.pagesCount)) return t.pageNumber = this._currentPageNumber, t.previousPageNumber = e, void this.container.dispatchEvent(t); t.previousPageNumber = this._currentPageNumber, this._currentPageNumber = e, t.pageNumber = e, this.container.dispatchEvent(t), this.updateInProgress || this.scrollPageIntoView(e) } else this._currentPageNumber = e }, get currentScale() { return this._currentScale !== UNKNOWN_SCALE ? this._currentScale : DEFAULT_SCALE }, set currentScale(e) { if (isNaN(e)) throw new Error("Invalid numeric scale"); if (!this.pdfDocument) return this._currentScale = e, void (this._currentScaleValue = e !== UNKNOWN_SCALE ? e.toString() : null); this._setScale(e, !1) }, get currentScaleValue() { return this._currentScaleValue }, set currentScaleValue(e) { if (!this.pdfDocument) return this._currentScale = isNaN(e) ? UNKNOWN_SCALE : e, void (this._currentScaleValue = e); this._setScale(e, !1) }, get pagesRotation() { return this._pagesRotation }, set pagesRotation(e) { this._pagesRotation = e; for (var t = 0, i = this._pages.length; t < i; t++) { var n = this._pages[t]; n.update(n.scale, e) } this._setScale(this._currentScaleValue, !0), this.defaultRenderingQueue && this.update() }, setDocument: function (e) { if (this.pdfDocument && this._resetView(), this.pdfDocument = e, e) { var t, i = e.numPages, n = this, s = new Promise(function (e) { t = e }); this.pagesPromise = s, s.then(function () { var e = document.createEvent("CustomEvent"); e.initCustomEvent("pagesloaded", !0, !0, { pagesCount: i }), n.container.dispatchEvent(e) }); var r = !1, a = null, o = new Promise(function (e) { a = e }); this.onePageRendered = o; var d = function (e) { e.onBeforeDraw = function () { n._buffer.push(this) }, e.onAfterDraw = function () { r || (r = !0, a()) } }, l = e.getPage(1); return this.firstPagePromise = l, l.then(function (s) { for (var r = this.currentScale, a = s.getViewport(r * CSS_UNITS), l = 1; l <= i; ++l) { var h = null; PDFJS.disableTextLayer || (h = this); var c = new PDFPageView({ container: this.viewer, id: l, scale: r, defaultViewport: a.clone(), renderingQueue: this.renderingQueue, textLayerFactory: h, annotationsLayerFactory: this }); d(c), this._pages.push(c) } var u = this.linkService; o.then(function () { if (PDFJS.disableAutoFetch) t(); else for (var s = i, r = 1; r <= i; ++r) e.getPage(r).then(function (e, i) { var r = n._pages[e - 1]; r.pdfPage || r.setPdfPage(i), u.cachePageRef(e, i.ref), --s || t() }.bind(null, r)) }); var p = document.createEvent("CustomEvent"); p.initCustomEvent("pagesinit", !0, !0, null), n.container.dispatchEvent(p), this.defaultRenderingQueue && this.update(), this.findController && this.findController.resolveFirstPage() }.bind(this)) } }, _resetView: function () { this._pages = [], this._currentPageNumber = 1, this._currentScale = UNKNOWN_SCALE, this._currentScaleValue = null, this._buffer = new e(DEFAULT_CACHE_SIZE), this._location = null, this._pagesRotation = 0, this._pagesRequests = []; for (var t = this.viewer; t.hasChildNodes() ;) t.removeChild(t.lastChild) }, _scrollUpdate: function () { if (0 !== this.pagesCount) { this.update(); for (var e = 0, t = this._pages.length; e < t; e++) this._pages[e].updatePosition() } }, _setScaleDispatchEvent: function (e, t, i) { var n = document.createEvent("UIEvents"); n.initUIEvent("scalechange", !0, !0, window, 0), n.scale = e, i && (n.presetValue = t), this.container.dispatchEvent(n) }, _setScaleUpdatePages: function (e, t, i, n) { if (this._currentScaleValue = t, function (e, t) { return t === e || Math.abs(t - e) < 1e-15 }(this._currentScale, e)) n && this._setScaleDispatchEvent(e, t, !0); else { for (var s = 0, r = this._pages.length; s < r; s++) this._pages[s].update(e); if (this._currentScale = e, !i) { var a, o = this._currentPageNumber; !this._location || IGNORE_CURRENT_POSITION_ON_ZOOM || this.isInPresentationMode || this.isChangingPresentationMode || (o = this._location.pageNumber, a = [null, { name: "XYZ" }, this._location.left, this._location.top, null]), this.scrollPageIntoView(o, a) } this._setScaleDispatchEvent(e, t, n), this.defaultRenderingQueue && this.update() } }, _setScale: function (e, t) { var i = parseFloat(e); if (i > 0) this._setScaleUpdatePages(i, e, t, !1); else { var n = this._pages[this._currentPageNumber - 1]; if (!n) return; var s = this.isInPresentationMode || this.removePageBorders ? 0 : SCROLLBAR_PADDING, r = this.isInPresentationMode || this.removePageBorders ? 0 : VERTICAL_PADDING, a = (this.container.clientWidth - s) / n.width * n.scale, o = (this.container.clientHeight - r) / n.height * n.scale; switch (e) { case "page-actual": i = 1; break; case "page-width": i = a; break; case "page-height": i = o; break; case "page-fit": i = Math.min(a, o); break; case "auto": var d = n.width > n.height ? Math.min(o, a) : a; i = Math.min(MAX_AUTO_SCALE, d); break; default: return void console.error("pdfViewSetScale: '" + e + "' is an unknown zoom value.") } this._setScaleUpdatePages(i, e, t, !0) } }, scrollPageIntoView: function (e, t) { if (this.pdfDocument) { var i = this._pages[e - 1]; if (this.isInPresentationMode) { if (this._currentPageNumber !== i.id) return void (this.currentPageNumber = i.id); t = null, this._setScale(this._currentScaleValue, !0) } if (t) { var n, s, r = 0, a = 0, o = 0, d = 0, l = i.rotation % 180 != 0, h = (l ? i.height : i.width) / i.scale / CSS_UNITS, c = (l ? i.width : i.height) / i.scale / CSS_UNITS, u = 0; switch (t[1].name) { case "XYZ": r = t[2], a = t[3], u = t[4], r = null !== r ? r : 0, a = null !== a ? a : c; break; case "Fit": case "FitB": u = "page-fit"; break; case "FitH": case "FitBH": u = "page-width", null === (a = t[2]) && this._location && (r = this._location.left, a = this._location.top); break; case "FitV": case "FitBV": r = t[2], o = h, d = c, u = "page-height"; break; case "FitR": r = t[2], a = t[3], o = t[4] - r, d = t[5] - a; var p = this.removePageBorders ? 0 : SCROLLBAR_PADDING, g = this.removePageBorders ? 0 : VERTICAL_PADDING; n = (this.container.clientWidth - p) / o / CSS_UNITS, s = (this.container.clientHeight - g) / d / CSS_UNITS, u = Math.min(Math.abs(n), Math.abs(s)); break; default: return } if (u && u !== this._currentScale ? this.currentScaleValue = u : this._currentScale === UNKNOWN_SCALE && (this.currentScaleValue = DEFAULT_SCALE_VALUE), "page-fit" !== u || t[4]) { var f = [i.viewport.convertToViewportPoint(r, a), i.viewport.convertToViewportPoint(r + o, a + d)], m = Math.min(f[0][0], f[1][0]), v = Math.min(f[0][1], f[1][1]); scrollIntoView(i.div, { left: m, top: v }) } else scrollIntoView(i.div) } else scrollIntoView(i.div) } }, _updateLocation: function (e) { var t = this._currentScale, i = this._currentScaleValue, n = parseFloat(i) === t ? Math.round(1e4 * t) / 100 : i, s = e.id, r = "#page=" + s; r += "&zoom=" + n; var a = this._pages[s - 1], o = this.container, d = a.getPagePoint(o.scrollLeft - e.x, o.scrollTop - e.y), l = Math.round(d[0]), h = Math.round(d[1]); r += "," + l + "," + h, this._location = { pageNumber: s, scale: n, top: h, left: l, pdfOpenParams: r } }, update: function () { var e = this._getVisiblePages(), t = e.views; if (0 !== t.length) { this.updateInProgress = !0; var i = Math.max(DEFAULT_CACHE_SIZE, 2 * t.length + 1); this._buffer.resize(i), this.renderingQueue.renderHighestPriority(e); for (var n = this._currentPageNumber, s = e.first, r = 0, a = t.length, o = !1; r < a; ++r) { var d = t[r]; if (d.percent < 100) break; if (d.id === n) { o = !0; break } } o || (n = t[0].id), this.isInPresentationMode || (this.currentPageNumber = n), this._updateLocation(s), this.updateInProgress = !1; var l = document.createEvent("UIEvents"); l.initUIEvent("updateviewarea", !0, !0, window, 0), l.location = this._location, this.container.dispatchEvent(l) } }, containsElement: function (e) { return this.container.contains(e) }, focus: function () { this.container.focus() }, get isInPresentationMode() { return this.presentationModeState === PresentationModeState.FULLSCREEN }, get isChangingPresentationMode() { return this.presentationModeState === PresentationModeState.CHANGING }, get isHorizontalScrollbarEnabled() { return !this.isInPresentationMode && this.container.scrollWidth > this.container.clientWidth }, _getVisiblePages: function () { if (this.isInPresentationMode) { var e = [], t = this._pages[this._currentPageNumber - 1]; return e.push({ id: t.id, view: t }), { first: t, last: t, views: e } } return getVisibleElements(this.container, this._pages, !0) }, cleanup: function () { for (var e = 0, t = this._pages.length; e < t; e++) this._pages[e] && this._pages[e].renderingState !== RenderingStates.FINISHED && this._pages[e].reset() }, _ensurePdfPageLoaded: function (e) { if (e.pdfPage) return Promise.resolve(e.pdfPage); var t = e.id; if (this._pagesRequests[t]) return this._pagesRequests[t]; var i = this.pdfDocument.getPage(t).then(function (i) { return e.setPdfPage(i), this._pagesRequests[t] = null, i }.bind(this)); return this._pagesRequests[t] = i, i }, forceRendering: function (e) { var t = e || this._getVisiblePages(), i = this.renderingQueue.getHighestPriority(t, this._pages, this.scroll.down); return !!i && (this._ensurePdfPageLoaded(i).then(function () { this.renderingQueue.renderView(i) }.bind(this)), !0) }, getPageTextContent: function (e) { return this.pdfDocument.getPage(e + 1).then(function (e) { return e.getTextContent() }) }, createTextLayerBuilder: function (e, t, i) { return new TextLayerBuilder({ textLayerDiv: e, pageIndex: t, viewport: i, findController: this.isInPresentationMode ? null : this.findController }) }, createAnnotationsLayerBuilder: function (e, t) { return new AnnotationsLayerBuilder({ pageDiv: e, pdfPage: t, linkService: this.linkService }) }, setFindController: function (e) { this.findController = e } }, t }(), SimpleLinkService = function () { function e() { } return e.prototype = { get page() { return 0 }, set page(e) { }, navigateTo: function (e) { }, getDestinationHash: function (e) { return "#" }, getAnchorUrl: function (e) { return "#" }, setHash: function (e) { }, executeNamedAction: function (e) { }, cachePageRef: function (e, t) { } }, e }(), THUMBNAIL_SCROLL_MARGIN = -19, THUMBNAIL_WIDTH = 98, THUMBNAIL_CANVAS_BORDER_WIDTH = 1, PDFThumbnailView = function () { function e(e) { var t = e.container, i = e.id, n = e.defaultViewport, s = e.linkService, r = e.renderingQueue; this.id = i, this.renderingId = "thumbnail" + i, this.pdfPage = null, this.rotation = 0, this.viewport = n, this.pdfPageRotate = n.rotation, this.linkService = s, this.renderingQueue = r, this.hasImage = !1, this.resume = null, this.renderingState = RenderingStates.INITIAL, this.pageWidth = this.viewport.width, this.pageHeight = this.viewport.height, this.pageRatio = this.pageWidth / this.pageHeight, this.canvasWidth = THUMBNAIL_WIDTH, this.canvasHeight = this.canvasWidth / this.pageRatio | 0, this.scale = this.canvasWidth / this.pageWidth; var a = document.createElement("a"); a.href = s.getAnchorUrl("#page=" + i), a.title = mozL10n.get("thumb_page_title", { page: i }, "Page {{page}}"), a.onclick = function () { return s.page = i, !1 }; var o = document.createElement("div"); o.id = "thumbnailContainer" + i, o.className = "thumbnail", this.div = o, 1 === i && o.classList.add("selected"); var d = document.createElement("div"); d.className = "thumbnailSelectionRing"; var l = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH; d.style.width = this.canvasWidth + l + "px", d.style.height = this.canvasHeight + l + "px", this.ring = d, o.appendChild(d), a.appendChild(o), t.appendChild(a) } return e.prototype = { setPdfPage: function (e) { this.pdfPage = e, this.pdfPageRotate = e.rotate; var t = (this.rotation + this.pdfPageRotate) % 360; this.viewport = e.getViewport(1, t), this.reset() }, reset: function () { this.renderTask && this.renderTask.cancel(), this.hasImage = !1, this.resume = null, this.renderingState = RenderingStates.INITIAL, this.pageWidth = this.viewport.width, this.pageHeight = this.viewport.height, this.pageRatio = this.pageWidth / this.pageHeight, this.canvasHeight = this.canvasWidth / this.pageRatio | 0, this.scale = this.canvasWidth / this.pageWidth, this.div.removeAttribute("data-loaded"); for (var e = this.ring, t = e.childNodes, i = t.length - 1; i >= 0; i--) e.removeChild(t[i]); var n = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH; e.style.width = this.canvasWidth + n + "px", e.style.height = this.canvasHeight + n + "px", this.canvas && (this.canvas.width = 0, this.canvas.height = 0, delete this.canvas), this.image && (this.image.removeAttribute("src"), delete this.image) }, update: function (e) { void 0 !== e && (this.rotation = e); var t = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: 1, rotation: t }), this.reset() }, _getPageDrawContext: function (e) { var t = document.createElement("canvas"); this.canvas = t; var i = t.getContext("2d"), n = getOutputScale(i); t.width = this.canvasWidth * n.sx | 0, t.height = this.canvasHeight * n.sy | 0, t.style.width = this.canvasWidth + "px", t.style.height = this.canvasHeight + "px", !e && n.scaled && i.scale(n.sx, n.sy); var s = document.createElement("img"); return this.image = s, s.id = this.renderingId, s.className = "thumbnailImage", s.setAttribute("aria-label", mozL10n.get("thumb_page_canvas", { page: this.id }, "Thumbnail of Page {{page}}")), s.style.width = t.style.width, s.style.height = t.style.height, i }, _convertCanvasToImage: function () { this.canvas && (this.image.src = this.canvas.toDataURL(), this.div.setAttribute("data-loaded", !0), this.ring.appendChild(this.image), this.canvas.width = 0, this.canvas.height = 0, delete this.canvas) }, draw: function () { if (this.renderingState !== RenderingStates.INITIAL && console.error("Must be in new state before drawing"), this.hasImage) return Promise.resolve(void 0); var e, t; this.hasImage = !0, this.renderingState = RenderingStates.RUNNING; var i = new Promise(function (i, n) { e = i, t = n }), n = this; function s(i) { a === n.renderTask && (n.renderTask = null), "cancelled" !== i ? (n.renderingState = RenderingStates.FINISHED, n._convertCanvasToImage(), i ? t(i) : e(void 0)) : t(i) } var r = { canvasContext: this._getPageDrawContext(), viewport: this.viewport.clone({ scale: this.scale }) }, a = this.renderTask = this.pdfPage.render(r); return a.onContinue = function (e) { if (!n.renderingQueue.isHighestPriority(n)) return n.renderingState = RenderingStates.PAUSED, void (n.resume = function () { n.renderingState = RenderingStates.RUNNING, e() }); e() }, a.promise.then(function () { s(null) }, function (e) { s(e) }), i }, setImage: function (t) { var i = t.canvas; if (!this.hasImage && i) { this.pdfPage || this.setPdfPage(t.pdfPage), this.hasImage = !0, this.renderingState = RenderingStates.FINISHED; var n = this._getPageDrawContext(!0), s = n.canvas; if (i.width <= 2 * s.width) return n.drawImage(i, 0, 0, i.width, i.height, 0, 0, s.width, s.height), void this._convertCanvasToImage(); for (var r = s.width << 3, a = s.height << 3, o = function (t, i) { var n = e.tempImageCache; n || (n = document.createElement("canvas"), e.tempImageCache = n), n.width = t, n.height = i; var s = n.getContext("2d"); return s.save(), s.fillStyle = "rgb(255, 255, 255)", s.fillRect(0, 0, t, i), s.restore(), n }(r, a), d = o.getContext("2d") ; r > i.width || a > i.height;) r >>= 1, a >>= 1; for (d.drawImage(i, 0, 0, i.width, i.height, 0, 0, r, a) ; r > 2 * s.width;) d.drawImage(o, 0, 0, r, a, 0, 0, r >> 1, a >> 1), r >>= 1, a >>= 1; n.drawImage(o, 0, 0, r, a, 0, 0, s.width, s.height), this._convertCanvasToImage() } } }, e }(); PDFThumbnailView.tempImageCache = null; var PDFThumbnailViewer = function () { function e(e) { this.container = e.container, this.renderingQueue = e.renderingQueue, this.linkService = e.linkService, this.scroll = watchScroll(this.container, this._scrollUpdated.bind(this)), this._resetView() } return e.prototype = { _scrollUpdated: function () { this.renderingQueue.renderHighestPriority() }, getThumbnail: function (e) { return this.thumbnails[e] }, _getVisibleThumbs: function () { return getVisibleElements(this.container, this.thumbnails) }, scrollThumbnailIntoView: function (e) { var t = document.querySelector(".thumbnail.selected"); t && t.classList.remove("selected"); var i = document.getElementById("thumbnailContainer" + e); i && i.classList.add("selected"); var n = this._getVisibleThumbs(), s = n.views.length; if (s > 0) { var r = n.first.id, a = s > 1 ? n.last.id : r; (e <= r || e >= a) && scrollIntoView(i, { top: THUMBNAIL_SCROLL_MARGIN }) } }, get pagesRotation() { return this._pagesRotation }, set pagesRotation(e) { this._pagesRotation = e; for (var t = 0, i = this.thumbnails.length; t < i; t++) { this.thumbnails[t].update(e) } }, cleanup: function () { var e = PDFThumbnailView.tempImageCache; e && (e.width = 0, e.height = 0), PDFThumbnailView.tempImageCache = null }, _resetView: function () { this.thumbnails = [], this._pagesRotation = 0, this._pagesRequests = [] }, setDocument: function (e) { if (this.pdfDocument) { for (var t = this.container; t.hasChildNodes() ;) t.removeChild(t.lastChild); this._resetView() } return this.pdfDocument = e, e ? e.getPage(1).then(function (t) { for (var i = e.numPages, n = t.getViewport(1), s = 1; s <= i; ++s) { var r = new PDFThumbnailView({ container: this.container, id: s, defaultViewport: n.clone(), linkService: this.linkService, renderingQueue: this.renderingQueue }); this.thumbnails.push(r) } }.bind(this)) : Promise.resolve() }, _ensurePdfPageLoaded: function (e) { if (e.pdfPage) return Promise.resolve(e.pdfPage); var t = e.id; if (this._pagesRequests[t]) return this._pagesRequests[t]; var i = this.pdfDocument.getPage(t).then(function (i) { return e.setPdfPage(i), this._pagesRequests[t] = null, i }.bind(this)); return this._pagesRequests[t] = i, i }, ensureThumbnailVisible: function (e) { scrollIntoView(document.getElementById("thumbnailContainer" + e)) }, forceRendering: function () { var e = this._getVisibleThumbs(), t = this.renderingQueue.getHighestPriority(e, this.thumbnails, this.scroll.down); return !!t && (this._ensurePdfPageLoaded(t).then(function () { this.renderingQueue.renderView(t) }.bind(this)), !0) } }, e }(), PDFOutlineView = function () { function e(e) { this.container = e.container, this.outline = e.outline, this.linkService = e.linkService, this.lastToggleIsShow = !0 } return e.prototype = { reset: function () { for (var e = this.container; e.firstChild;) e.removeChild(e.firstChild); this.lastToggleIsShow = !0 }, _dispatchEvent: function (e) { var t = document.createEvent("CustomEvent"); t.initCustomEvent("outlineloaded", !0, !0, { outlineCount: e }), this.container.dispatchEvent(t) }, _bindLink: function (e, t) { var i = this.linkService; e.href = i.getDestinationHash(t.dest), e.onclick = function (e) { return i.navigateTo(t.dest), !1 } }, _addToggleButton: function (e) { var t = document.createElement("div"); t.className = "outlineItemToggler", t.onclick = function (i) { if (i.stopPropagation(), t.classList.toggle("outlineItemsHidden"), i.shiftKey) { var n = !t.classList.contains("outlineItemsHidden"); this._toggleOutlineItem(e, n) } }.bind(this), e.insertBefore(t, e.firstChild) }, _toggleOutlineItem: function (e, t) { this.lastToggleIsShow = t; for (var i = e.querySelectorAll(".outlineItemToggler"), n = 0, s = i.length; n < s; ++n) i[n].classList[t ? "remove" : "add"]("outlineItemsHidden") }, toggleOutlineTree: function () { this._toggleOutlineItem(this.container, !this.lastToggleIsShow) }, render: function () { var e = this.outline, t = 0; if (this.reset(), e) { for (var i = document.createDocumentFragment(), n = [{ parent: i, items: this.outline }], s = !1; n.length > 0;) for (var r = n.shift(), a = 0, o = r.items.length; a < o; a++) { var d = r.items[a], l = document.createElement("div"); l.className = "outlineItem"; var h = document.createElement("a"); if (this._bindLink(h, d), h.textContent = removeNullCharacters(d.title), l.appendChild(h), d.items.length > 0) { s = !0, this._addToggleButton(l); var c = document.createElement("div"); c.className = "outlineItems", l.appendChild(c), n.push({ parent: c, items: d.items }) } r.parent.appendChild(l), t++ } s && this.container.classList.add("outlineWithDeepNesting"), this.container.appendChild(i), this._dispatchEvent(t) } else this._dispatchEvent(t) } }, e }(), PDFAttachmentView = function () { function e(e) { this.container = e.container, this.attachments = e.attachments, this.downloadManager = e.downloadManager } return e.prototype = { reset: function () { for (var e = this.container; e.firstChild;) e.removeChild(e.firstChild) }, _dispatchEvent: function (e) { var t = document.createEvent("CustomEvent"); t.initCustomEvent("attachmentsloaded", !0, !0, { attachmentsCount: e }), this.container.dispatchEvent(t) }, _bindLink: function (e, t, i) { e.onclick = function (e) { return this.downloadManager.downloadData(t, i, ""), !1 }.bind(this) }, render: function () { var e = this.attachments, t = 0; if (this.reset(), e) { var i = Object.keys(e).sort(function (e, t) { return e.toLowerCase().localeCompare(t.toLowerCase()) }); t = i.length; for (var n = 0; n < t; n++) { var s = e[i[n]], r = getFileName(s.filename), a = document.createElement("div"); a.className = "attachmentsItem"; var o = document.createElement("button"); this._bindLink(o, s.content, r), o.textContent = removeNullCharacters(r), a.appendChild(o), this.container.appendChild(a) } this._dispatchEvent(t) } else this._dispatchEvent(t) } }, e }(), PDFViewerApplication = { initialBookmark: document.location.hash.substring(1), initialDestination: null, initialized: !1, fellback: !1, pdfDocument: null, pdfLoadingTask: null, sidebarOpen: !1, printing: !1, pdfViewer: null, pdfThumbnailViewer: null, pdfRenderingQueue: null, pdfPresentationMode: null, pdfDocumentProperties: null, pdfLinkService: null, pdfHistory: null, pageRotation: 0, isInitialViewSet: !1, animationStartedPromise: null, preferenceSidebarViewOnLoad: SidebarView.NONE, preferencePdfBugEnabled: !1, preferenceShowPreviousViewOnLoad: !0, preferenceDefaultZoomValue: "", isViewerEmbedded: window.parent !== window, url: "", initialize: function () { var e = new PDFRenderingQueue; e.onIdle = this.cleanup.bind(this), this.pdfRenderingQueue = e; var t = new PDFLinkService; this.pdfLinkService = t; var i = document.getElementById("viewerContainer"), n = document.getElementById("viewer"); this.pdfViewer = new PDFViewer({ container: i, viewer: n, renderingQueue: e, linkService: t }), e.setViewer(this.pdfViewer), t.setViewer(this.pdfViewer); var s = document.getElementById("thumbnailView"); if (this.pdfThumbnailViewer = new PDFThumbnailViewer({ container: s, renderingQueue: e, linkService: t }), e.setThumbnailViewer(this.pdfThumbnailViewer), Preferences.initialize(), this.pdfHistory = new PDFHistory({ linkService: t }), t.setHistory(this.pdfHistory), this.findController = new PDFFindController({ pdfViewer: this.pdfViewer, integratedFind: this.supportsIntegratedFind }), this.pdfViewer.setFindController(this.findController), this.findBar = new PDFFindBar({ bar: document.getElementById("findbar"), toggleButton: document.getElementById("viewFind"), findField: document.getElementById("findInput"), highlightAllCheckbox: document.getElementById("findHighlightAll"), caseSensitiveCheckbox: document.getElementById("findMatchCase"), findMsg: document.getElementById("findMsg"), findResultsCount: document.getElementById("findResultsCount"), findStatusIcon: document.getElementById("findStatusIcon"), findPreviousButton: document.getElementById("findPrevious"), findNextButton: document.getElementById("findNext"), findController: this.findController }), this.findController.setFindBar(this.findBar), HandTool.initialize({ container: i, toggleHandTool: document.getElementById("toggleHandTool") }), this.pdfDocumentProperties = new PDFDocumentProperties({ overlayName: "documentPropertiesOverlay", closeButton: document.getElementById("documentPropertiesClose"), fields: { fileName: document.getElementById("fileNameField"), fileSize: document.getElementById("fileSizeField"), title: document.getElementById("titleField"), author: document.getElementById("authorField"), subject: document.getElementById("subjectField"), keywords: document.getElementById("keywordsField"), creationDate: document.getElementById("creationDateField"), modificationDate: document.getElementById("modificationDateField"), creator: document.getElementById("creatorField"), producer: document.getElementById("producerField"), version: document.getElementById("versionField"), pageCount: document.getElementById("pageCountField") } }), SecondaryToolbar.initialize({ toolbar: document.getElementById("secondaryToolbar"), toggleButton: document.getElementById("secondaryToolbarToggle"), presentationModeButton: document.getElementById("secondaryPresentationMode"), openFile: document.getElementById("secondaryOpenFile"), print: document.getElementById("secondaryPrint"), download: document.getElementById("secondaryDownload"), viewBookmark: document.getElementById("secondaryViewBookmark"), firstPage: document.getElementById("firstPage"), lastPage: document.getElementById("lastPage"), pageRotateCw: document.getElementById("pageRotateCw"), pageRotateCcw: document.getElementById("pageRotateCcw"), documentPropertiesButton: document.getElementById("documentProperties") }), this.supportsFullscreen) { var r = SecondaryToolbar; this.pdfPresentationMode = new PDFPresentationMode({ container: i, viewer: n, pdfViewer: this.pdfViewer, pdfThumbnailViewer: this.pdfThumbnailViewer, contextMenuItems: [{ element: document.getElementById("contextFirstPage"), handler: r.firstPageClick.bind(r) }, { element: document.getElementById("contextLastPage"), handler: r.lastPageClick.bind(r) }, { element: document.getElementById("contextPageRotateCw"), handler: r.pageRotateCwClick.bind(r) }, { element: document.getElementById("contextPageRotateCcw"), handler: r.pageRotateCcwClick.bind(r) }] }) } PasswordPrompt.initialize({ overlayName: "passwordOverlay", passwordField: document.getElementById("password"), passwordText: document.getElementById("passwordText"), passwordSubmit: document.getElementById("passwordSubmit"), passwordCancel: document.getElementById("passwordCancel") }); var a = this; return Promise.all([Preferences.get("enableWebGL").then(function (e) { PDFJS.disableWebGL = !e }), Preferences.get("sidebarViewOnLoad").then(function (e) { a.preferenceSidebarViewOnLoad = e }), Preferences.get("pdfBugEnabled").then(function (e) { a.preferencePdfBugEnabled = e }), Preferences.get("showPreviousViewOnLoad").then(function (e) { a.preferenceShowPreviousViewOnLoad = e }), Preferences.get("defaultZoomValue").then(function (e) { a.preferenceDefaultZoomValue = e }), Preferences.get("disableTextLayer").then(function (e) { !0 !== PDFJS.disableTextLayer && (PDFJS.disableTextLayer = e) }), Preferences.get("disableRange").then(function (e) { !0 !== PDFJS.disableRange && (PDFJS.disableRange = e) }), Preferences.get("disableStream").then(function (e) { !0 !== PDFJS.disableStream && (PDFJS.disableStream = e) }), Preferences.get("disableAutoFetch").then(function (e) { PDFJS.disableAutoFetch = e }), Preferences.get("disableFontFace").then(function (e) { !0 !== PDFJS.disableFontFace && (PDFJS.disableFontFace = e) }), Preferences.get("useOnlyCssZoom").then(function (e) { PDFJS.useOnlyCssZoom = e }), Preferences.get("externalLinkTarget").then(function (e) { PDFJS.isExternalLinkTargetSet() || (PDFJS.externalLinkTarget = e) })]).catch(function (e) { }).then(function () { a.isViewerEmbedded && !PDFJS.isExternalLinkTargetSet() && (PDFJS.externalLinkTarget = PDFJS.LinkTarget.TOP), a.initialized = !0 }) }, zoomIn: function (e) { var t = this.pdfViewer.currentScale; do { t = (t * DEFAULT_SCALE_DELTA).toFixed(2), t = Math.ceil(10 * t) / 10, t = Math.min(MAX_SCALE, t) } while (--e > 0 && t < MAX_SCALE); this.pdfViewer.currentScaleValue = t }, zoomOut: function (e) { var t = this.pdfViewer.currentScale; do { t = (t / DEFAULT_SCALE_DELTA).toFixed(2), t = Math.floor(10 * t) / 10, t = Math.max(MIN_SCALE, t) } while (--e > 0 && t > MIN_SCALE); this.pdfViewer.currentScaleValue = t }, get pagesCount() { return this.pdfDocument.numPages }, set page(e) { this.pdfLinkService.page = e }, get page() { return this.pdfLinkService.page }, get supportsPrinting() { var e = "mozPrintCallback" in document.createElement("canvas"); return PDFJS.shadow(this, "supportsPrinting", e) }, get supportsFullscreen() { var e = document.documentElement, t = !!(e.requestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullScreen || e.msRequestFullscreen); return !1 !== document.fullscreenEnabled && !1 !== document.mozFullScreenEnabled && !1 !== document.webkitFullscreenEnabled && !1 !== document.msFullscreenEnabled || (t = !1), t && !0 === PDFJS.disableFullscreen && (t = !1), PDFJS.shadow(this, "supportsFullscreen", t) }, get supportsIntegratedFind() { return PDFJS.shadow(this, "supportsIntegratedFind", !1) }, get supportsDocumentFonts() { return PDFJS.shadow(this, "supportsDocumentFonts", !0) }, get supportsDocumentColors() { return PDFJS.shadow(this, "supportsDocumentColors", !0) }, get loadingBar() { var e = new ProgressBar("#loadingBar", {}); return PDFJS.shadow(this, "loadingBar", e) }, get supportedMouseWheelZoomModifierKeys() { return PDFJS.shadow(this, "supportedMouseWheelZoomModifierKeys", { ctrlKey: !0, metaKey: !0 }) }, setTitleUsingUrl: function (e) { this.url = e; try { this.setTitle(decodeURIComponent(getFileName(e)) || e) } catch (t) { this.setTitle(e) } }, setTitle: function (e) { document.title = titleheader }, close: function () { if (document.getElementById("errorWrapper").setAttribute("hidden", "true"), !this.pdfLoadingTask) return Promise.resolve(); var e = this.pdfLoadingTask.destroy(); return this.pdfLoadingTask = null, this.pdfDocument && (this.pdfDocument = null, this.pdfThumbnailViewer.setDocument(null), this.pdfViewer.setDocument(null), this.pdfLinkService.setDocument(null, null)), "undefined" != typeof PDFBug && PDFBug.cleanup(), e }, open: function (e, t) { var i = 0; if ((arguments.length > 2 || "number" == typeof t) && (console.warn("Call of open() with obsolete signature."), "number" == typeof t && (i = t), t = arguments[4] || null, arguments[3] && "object" == typeof arguments[3] && ((t = Object.create(t)).range = arguments[3]), "string" == typeof arguments[2] && ((t = Object.create(t)).password = arguments[2])), this.pdfLoadingTask) return this.close().then(function () { return Preferences.reload(), this.open(e, t) }.bind(this)); var n = Object.create(null); if ("string" == typeof e ? (this.setTitleUsingUrl(e), n.url = e) : e && "byteLength" in e ? n.data = e : e.url && e.originalUrl && (this.setTitleUsingUrl(e.originalUrl), n.url = e.url), t) for (var s in t) n[s] = t[s]; var r = this; r.downloadComplete = !1; var a = PDFJS.getDocument(n); this.pdfLoadingTask = a, a.onPassword = function (e, t) { PasswordPrompt.updatePassword = e, PasswordPrompt.reason = t, PasswordPrompt.open() }, a.onProgress = function (e) { r.progress(e.loaded / e.total) }; var o = a.promise.then(function (e) { r.load(e, i) }, function (e) { var t = e && e.message, i = mozL10n.get("loading_error", null, "Không tìm thấy dữ liệu vui lòng thử lại hoặc liên hệ nguyennhatquang@pymepharco.com."); e instanceof PDFJS.InvalidPDFException ? i = mozL10n.get("invalid_file_error", null, "Invalid or corrupted PDF file.") : e instanceof PDFJS.MissingPDFException ? i = mozL10n.get("missing_file_error", null, "Missing PDF file.") : e instanceof PDFJS.UnexpectedResponseException && (i = mozL10n.get("unexpected_response_error", null, "Unexpected server response.")); var n = { message: t }; throw r.error(i, n), new Error(i) }); return t && t.length && PDFViewerApplication.pdfDocumentProperties.setFileSize(t.length), o }, download: function () { function e() { n.downloadUrl(t, i) } var t = this.url.split("#")[0], i = getPDFFileNameFromURL(t), n = new DownloadManager; n.onerror = function (e) { PDFViewerApplication.error("PDF failed to download.") }, this.pdfDocument && this.downloadComplete ? this.pdfDocument.getData().then(function (e) { var s = PDFJS.createBlob(e, "application/pdf"); n.download(s, t, i) }, e).then(null, e) : e() }, fallback: function (e) { }, error: function (e, t) { var i = mozL10n.get("error_version_info", { version: PDFJS.version || "?", build: PDFJS.build || "?" }, "PDF.js v{{version}} (build: {{build}})") + "\n"; t && (i += mozL10n.get("error_message", { message: t.message }, "Message: {{message}}"), t.stack ? i += "\n" + mozL10n.get("error_stack", { stack: t.stack }, "Stack: {{stack}}") : (t.filename && (i += "\n" + mozL10n.get("error_file", { file: t.filename }, "File: {{file}}")), t.lineNumber && (i += "\n" + mozL10n.get("error_line", { line: t.lineNumber }, "Line: {{line}}")))); var n = document.getElementById("errorWrapper"); n.removeAttribute("hidden"), document.getElementById("errorMessage").textContent = e; var s = document.getElementById("errorClose"); s.onclick = function () { n.setAttribute("hidden", "true") }; var r = document.getElementById("errorMoreInfo"), a = document.getElementById("errorShowMore"), o = document.getElementById("errorShowLess"); a.onclick = function () { r.removeAttribute("hidden"), a.setAttribute("hidden", "true"), o.removeAttribute("hidden"), r.style.height = r.scrollHeight + "px" }, o.onclick = function () { r.setAttribute("hidden", "true"), a.removeAttribute("hidden"), o.setAttribute("hidden", "true") }, a.oncontextmenu = noContextMenuHandler, o.oncontextmenu = noContextMenuHandler, s.oncontextmenu = noContextMenuHandler, a.removeAttribute("hidden"), o.setAttribute("hidden", "true"), r.value = i }, progress: function (e) { var t = Math.round(100 * e); (t > this.loadingBar.percent || isNaN(t)) && (this.loadingBar.percent = t, PDFJS.disableAutoFetch && t && (this.disableAutoFetchLoadingBarTimeout && (clearTimeout(this.disableAutoFetchLoadingBarTimeout), this.disableAutoFetchLoadingBarTimeout = null), this.loadingBar.show(), this.disableAutoFetchLoadingBarTimeout = setTimeout(function () { this.loadingBar.hide(), this.disableAutoFetchLoadingBarTimeout = null }.bind(this), DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT))) }, load: function (e, t) { var i = this; t = t || UNKNOWN_SCALE, this.findController.reset(), this.pdfDocument = e, this.pdfDocumentProperties.setDocumentAndUrl(e, this.url); var n = e.getDownloadInfo().then(function () { i.downloadComplete = !0, i.loadingBar.hide() }), s = e.numPages; document.getElementById("numPages").textContent = mozL10n.get("page_of", { pageCount: s }, "of {{pageCount}}"), document.getElementById("pageNumber").max = s; var r = this.documentFingerprint = e.fingerprint, a = this.store = new ViewHistory(r); this.pdfLinkService.setDocument(e, null); var o = this.pdfViewer; o.currentScale = t, o.setDocument(e); var d = o.firstPagePromise, l = o.pagesPromise, h = o.onePageRendered; this.pageRotation = 0, this.isInitialViewSet = !1, this.pdfThumbnailViewer.setDocument(e), d.then(function (e) { n.then(function () { var e = document.createEvent("CustomEvent"); e.initCustomEvent("documentload", !0, !0, {}), window.dispatchEvent(e) }), i.loadingBar.setWidth(document.getElementById("viewer")), PDFJS.disableHistory || i.isViewerEmbedded || (i.preferenceShowPreviousViewOnLoad || i.pdfHistory.clearHistoryState(), i.pdfHistory.initialize(i.documentFingerprint), i.pdfHistory.initialDestination ? i.initialDestination = i.pdfHistory.initialDestination : i.pdfHistory.initialBookmark && (i.initialBookmark = i.pdfHistory.initialBookmark)); var s = { destination: i.initialDestination, bookmark: i.initialBookmark, hash: null }; a.initializedPromise.then(function () { var e = null; i.preferenceShowPreviousViewOnLoad && a.get("exists", !1) ? e = "page=" + a.get("page", "1") + "&zoom=" + (i.preferenceDefaultZoomValue || a.get("zoom", DEFAULT_SCALE_VALUE)) + "," + a.get("scrollLeft", "0") + "," + a.get("scrollTop", "0") : i.preferenceDefaultZoomValue && (e = "page=1&zoom=" + i.preferenceDefaultZoomValue); i.setInitialView(e, t), s.hash = e, i.isViewerEmbedded || i.pdfViewer.focus() }, function (e) { console.error(e), i.setInitialView(null, t) }), l.then(function () { (s.destination || s.bookmark || s.hash) && (i.hasEqualPageSizes || (i.initialDestination = s.destination, i.initialBookmark = s.bookmark, i.pdfViewer.currentScaleValue = i.pdfViewer.currentScaleValue, i.setInitialView(s.hash, t))) }) }), l.then(function () { i.supportsPrinting && e.getJavaScript().then(function (e) { e.length && (console.warn("Warning: JavaScript is not supported"), i.fallback(PDFJS.UNSUPPORTED_FEATURES.javaScript)); for (var t = /\bprint\s*\(/, n = 0, s = e.length; n < s; n++) { var r = e[n]; if (r && t.test(r)) return void setTimeout(function () { window.print() }) } }) }); var c = [l, this.animationStartedPromise]; Promise.all(c).then(function () { e.getOutline().then(function (e) { var t = document.getElementById("outlineView"); i.outline = new PDFOutlineView({ container: t, outline: e, linkService: i.pdfLinkService }), i.outline.render(), document.getElementById("viewOutline").disabled = !e, e || t.classList.contains("hidden") || i.switchSidebarView("thumbs"), e && i.preferenceSidebarViewOnLoad === SidebarView.OUTLINE && i.switchSidebarView("outline", !0) }), e.getAttachments().then(function (e) { var t = document.getElementById("attachmentsView"); i.attachments = new PDFAttachmentView({ container: t, attachments: e, downloadManager: new DownloadManager }), i.attachments.render(), document.getElementById("viewAttachments").disabled = !e, e || t.classList.contains("hidden") || i.switchSidebarView("thumbs"), e && i.preferenceSidebarViewOnLoad === SidebarView.ATTACHMENTS && i.switchSidebarView("attachments", !0) }) }), i.preferenceSidebarViewOnLoad === SidebarView.THUMBS && Promise.all([d, h]).then(function () { i.switchSidebarView("thumbs", !0) }), e.getMetadata().then(function (t) { var n, s = t.info, r = t.metadata; if (i.documentInfo = s, i.metadata = r, console.log("PDF " + e.fingerprint + " [" + s.PDFFormatVersion + " " + (s.Producer || "-").trim() + " / " + (s.Creator || "-").trim() + "] (PDF.js: " + (PDFJS.version || "-") + (PDFJS.disableWebGL ? "" : " [WebGL]") + ")"), r && r.has("dc:title")) { var a = r.get("dc:title"); "Untitled" !== a && (n = a) } !n && s && s.Title && (n = s.Title), n && i.setTitle(n + " - " + document.title), s.IsAcroFormPresent && (console.warn("Warning: AcroForm/XFA is not supported"), i.fallback(PDFJS.UNSUPPORTED_FEATURES.forms)) }) }, setInitialView: function (e, t) { this.isInitialViewSet = !0, document.getElementById("pageNumber").value = this.pdfViewer.currentPageNumber, this.initialDestination ? (this.pdfLinkService.navigateTo(this.initialDestination), this.initialDestination = null) : this.initialBookmark ? (this.pdfLinkService.setHash(this.initialBookmark), this.pdfHistory.push({ hash: this.initialBookmark }, !0), this.initialBookmark = null) : e ? this.pdfLinkService.setHash(e) : t && (this.pdfViewer.currentScaleValue = t, this.page = 1), this.pdfViewer.currentScaleValue || (this.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE) }, cleanup: function () { this.pdfDocument && (this.pdfViewer.cleanup(), this.pdfThumbnailViewer.cleanup(), this.pdfDocument.cleanup()) }, forceRendering: function () { this.pdfRenderingQueue.printing = this.printing, this.pdfRenderingQueue.isThumbnailViewEnabled = this.sidebarOpen, this.pdfRenderingQueue.renderHighestPriority() }, refreshThumbnailViewer: function () { for (var e = this.pdfViewer, t = this.pdfThumbnailViewer, i = e.pagesCount, n = 0; n < i; n++) { var s = e.getPageView(n); if (s && s.renderingState === RenderingStates.FINISHED) t.getThumbnail(n).setImage(s) } t.scrollThumbnailIntoView(this.page) }, switchSidebarView: function (e, t) { t && !this.sidebarOpen && document.getElementById("sidebarToggle").click(); var i = document.getElementById("thumbnailView"), n = document.getElementById("outlineView"), s = document.getElementById("attachmentsView"), r = document.getElementById("viewThumbnail"), a = document.getElementById("viewOutline"), o = document.getElementById("viewAttachments"); switch (e) { case "thumbs": var d = i.classList.contains("hidden"); r.classList.add("toggled"), a.classList.remove("toggled"), o.classList.remove("toggled"), i.classList.remove("hidden"), n.classList.add("hidden"), s.classList.add("hidden"), this.forceRendering(), d && this.pdfThumbnailViewer.ensureThumbnailVisible(this.page); break; case "outline": if (a.disabled) return; r.classList.remove("toggled"), a.classList.add("toggled"), o.classList.remove("toggled"), i.classList.add("hidden"), n.classList.remove("hidden"), s.classList.add("hidden"); break; case "attachments": if (o.disabled) return; r.classList.remove("toggled"), a.classList.remove("toggled"), o.classList.add("toggled"), i.classList.add("hidden"), n.classList.add("hidden"), s.classList.remove("hidden") } }, beforePrint: function () { if (this.supportsPrinting) { var e, t, i = !1; if (this.pdfDocument && this.pagesCount) { for (e = 0, t = this.pagesCount; e < t; ++e) if (!this.pdfViewer.getPageView(e).pdfPage) { i = !0; break } } else i = !0; if (i) { var n = mozL10n.get("printing_not_ready", null, "Warning: The PDF is not fully loaded for printing."); window.alert(n) } else { this.printing = !0, this.forceRendering(); var s = document.querySelector("body"); s.setAttribute("data-mozPrintCallback", !0), this.hasEqualPageSizes || console.warn("Not all pages have the same size. The printed result may be incorrect!"), this.pageStyleSheet = document.createElement("style"); var r = this.pdfViewer.getPageView(0).pdfPage.getViewport(1); for (this.pageStyleSheet.textContent = "@supports ((size:A4) and (size:1pt 1pt)) {@page { size: " + r.width + "pt " + r.height + "pt;}#printContainer {height:100%}#printContainer > div {width:100% !important;height:100% !important;}}", s.appendChild(this.pageStyleSheet), e = 0, t = this.pagesCount; e < t; ++e) this.pdfViewer.getPageView(e).beforePrint() } } else { var a = mozL10n.get("printing_not_supported", null, "Warning: Printing is not fully supported by this browser."); this.error(a) } }, get hasEqualPageSizes() { for (var e = this.pdfViewer.getPageView(0), t = 1, i = this.pagesCount; t < i; ++t) { var n = this.pdfViewer.getPageView(t); if (n.width !== e.width || n.height !== e.height) return !1 } return !0 }, afterPrint: function () { for (var e = document.getElementById("printContainer") ; e.hasChildNodes() ;) e.removeChild(e.lastChild); this.pageStyleSheet && this.pageStyleSheet.parentNode && (this.pageStyleSheet.parentNode.removeChild(this.pageStyleSheet), this.pageStyleSheet = null), this.printing = !1, this.forceRendering() }, rotatePages: function (e) { var t = this.page; this.pageRotation = (this.pageRotation + 360 + e) % 360, this.pdfViewer.pagesRotation = this.pageRotation, this.pdfThumbnailViewer.pagesRotation = this.pageRotation, this.forceRendering(), this.pdfViewer.scrollPageIntoView(t) }, requestPresentationMode: function () { this.pdfPresentationMode && this.pdfPresentationMode.request() }, scrollPresentationMode: function (e) { this.pdfPresentationMode && this.pdfPresentationMode.mouseScroll(e) } }; function webViewerLoad(e) { PDFViewerApplication.initialize().then(webViewerInitialized) } function webViewerInitialized() { var e = parseQueryString(document.location.search.substring(1)), t = "file" in e ? e.file : DEFAULT_URL, i = document.createElement("input"); i.id = "fileInput", i.className = "fileInput", i.setAttribute("type", "file"), i.oncontextmenu = noContextMenuHandler, document.body.appendChild(i), window.File && window.FileReader && window.FileList && window.Blob ? document.getElementById("fileInput").value = null : (document.getElementById("openFile").setAttribute("hidden", "true"), document.getElementById("secondaryOpenFile").setAttribute("hidden", "true")); var n = PDFJS.locale || navigator.language; if (PDFViewerApplication.preferencePdfBugEnabled) { var s = parseQueryString(document.location.hash.substring(1)); if ("disableworker" in s && (PDFJS.disableWorker = "true" === s.disableworker), "disablerange" in s && (PDFJS.disableRange = "true" === s.disablerange), "disablestream" in s && (PDFJS.disableStream = "true" === s.disablestream), "disableautofetch" in s && (PDFJS.disableAutoFetch = "true" === s.disableautofetch), "disablefontface" in s && (PDFJS.disableFontFace = "true" === s.disablefontface), "disablehistory" in s && (PDFJS.disableHistory = "true" === s.disablehistory), "webgl" in s && (PDFJS.disableWebGL = "true" !== s.webgl), "useonlycsszoom" in s && (PDFJS.useOnlyCssZoom = "true" === s.useonlycsszoom), "verbosity" in s && (PDFJS.verbosity = 0 | s.verbosity), "ignorecurrentpositiononzoom" in s && (IGNORE_CURRENT_POSITION_ON_ZOOM = "true" === s.ignorecurrentpositiononzoom), "locale" in s && (n = s.locale), "textlayer" in s) switch (s.textlayer) { case "off": PDFJS.disableTextLayer = !0; break; case "visible": case "shadow": case "hover": document.getElementById("viewer").classList.add("textLayer-" + s.textlayer) } if ("pdfbug" in s) { PDFJS.pdfBug = !0; var r = s.pdfbug.split(","); PDFBug.enable(r), PDFBug.init() } } mozL10n.setLanguage(n), PDFViewerApplication.supportsPrinting || (document.getElementById("print").classList.add("hidden"), document.getElementById("secondaryPrint").classList.add("hidden")), PDFViewerApplication.supportsFullscreen || (document.getElementById("presentationMode").classList.add("hidden"), document.getElementById("secondaryPresentationMode").classList.add("hidden")), PDFViewerApplication.supportsIntegratedFind && document.getElementById("viewFind").classList.add("hidden"), PDFJS.UnsupportedManager.listen(PDFViewerApplication.fallback.bind(PDFViewerApplication)), document.getElementById("scaleSelect").oncontextmenu = noContextMenuHandler; var a = document.getElementById("mainContainer"), o = document.getElementById("outerContainer"); if (a.addEventListener("transitionend", function (e) { if (e.target === a) { var t = document.createEvent("UIEvents"); t.initUIEvent("resize", !1, !1, window, 0), window.dispatchEvent(t), o.classList.remove("sidebarMoving") } }, !0), document.getElementById("sidebarToggle").addEventListener("click", function () { this.classList.toggle("toggled"), o.classList.add("sidebarMoving"), o.classList.toggle("sidebarOpen"), PDFViewerApplication.sidebarOpen = o.classList.contains("sidebarOpen"), PDFViewerApplication.sidebarOpen && PDFViewerApplication.refreshThumbnailViewer(), PDFViewerApplication.forceRendering() }), document.getElementById("viewThumbnail").addEventListener("click", function () { PDFViewerApplication.switchSidebarView("thumbs") }), document.getElementById("viewOutline").addEventListener("click", function () { PDFViewerApplication.switchSidebarView("outline") }), document.getElementById("viewOutline").addEventListener("dblclick", function () { PDFViewerApplication.outline.toggleOutlineTree() }), document.getElementById("viewAttachments").addEventListener("click", function () { PDFViewerApplication.switchSidebarView("attachments") }), document.getElementById("previous").addEventListener("click", function () { PDFViewerApplication.page-- }), document.getElementById("next").addEventListener("click", function () { PDFViewerApplication.page++ }), document.getElementById("zoomIn").addEventListener("click", function () { PDFViewerApplication.zoomIn() }), document.getElementById("zoomOut").addEventListener("click", function () { PDFViewerApplication.zoomOut() }), document.getElementById("pageNumber").addEventListener("click", function () { this.select() }), document.getElementById("pageNumber").addEventListener("change", function () { PDFViewerApplication.page = 0 | this.value, this.value !== (0 | this.value).toString() && (this.value = PDFViewerApplication.page) }), document.getElementById("scaleSelect").addEventListener("change", function () { "custom" !== this.value && (PDFViewerApplication.pdfViewer.currentScaleValue = this.value) }), document.getElementById("presentationMode").addEventListener("click", SecondaryToolbar.presentationModeClick.bind(SecondaryToolbar)), document.getElementById("openFile").addEventListener("click", SecondaryToolbar.openFileClick.bind(SecondaryToolbar)), document.getElementById("print").addEventListener("click", SecondaryToolbar.printClick.bind(SecondaryToolbar)), document.getElementById("download").addEventListener("click", SecondaryToolbar.downloadClick.bind(SecondaryToolbar)), t && 0 === t.lastIndexOf("file:", 0)) { PDFViewerApplication.setTitleUsingUrl(t); var d = new XMLHttpRequest; d.onload = function () { PDFViewerApplication.open(new Uint8Array(d.response)) }; try { d.open("GET", t), d.responseType = "arraybuffer", d.send() } catch (e) { PDFViewerApplication.error(mozL10n.get("loading_error", null, "An error occurred while loading the PDF."), e) } } else t && PDFViewerApplication.open(t) } function selectScaleOption(e) { for (var t = document.getElementById("scaleSelect").options, i = !1, n = 0, s = t.length; n < s; n++) { var r = t[n]; r.value === e ? (r.selected = !0, i = !0) : r.selected = !1 } return i } function handleMouseWheel(e) { var t = "DOMMouseScroll" === e.type ? -e.detail : e.wheelDelta / 40, i = t < 0 ? "zoomOut" : "zoomIn", n = PDFViewerApplication.pdfViewer; if (n.isInPresentationMode) e.preventDefault(), PDFViewerApplication.scrollPresentationMode(40 * t); else if (e.ctrlKey || e.metaKey) { var s = PDFViewerApplication.supportedMouseWheelZoomModifierKeys; if (e.ctrlKey && !s.ctrlKey || e.metaKey && !s.metaKey) return; e.preventDefault(); var r = n.currentScale; PDFViewerApplication[i](Math.abs(t)); var a = n.currentScale; if (r !== a) { var o = a / r - 1, d = n.container.getBoundingClientRect(), l = e.clientX - d.left, h = e.clientY - d.top; n.container.scrollLeft += l * o, n.container.scrollTop += h * o } } } window.PDFView = PDFViewerApplication, document.addEventListener("DOMContentLoaded", webViewerLoad, !0), document.addEventListener("pagerendered", function (e) { var t = e.detail.pageNumber, i = t - 1, n = PDFViewerApplication.pdfViewer.getPageView(i); PDFViewerApplication.sidebarOpen && PDFViewerApplication.pdfThumbnailViewer.getThumbnail(i).setImage(n); (PDFJS.pdfBug && Stats.enabled && n.stats && Stats.add(t, n.stats), n.error && PDFViewerApplication.error(mozL10n.get("rendering_error", null, "An error occurred while rendering the page."), n.error), t === PDFViewerApplication.page) && document.getElementById("pageNumber").classList.remove(PAGE_NUMBER_LOADING_INDICATOR) }, !0), document.addEventListener("textlayerrendered", function (e) { var t = e.detail.pageNumber - 1; PDFViewerApplication.pdfViewer.getPageView(t) }, !0), document.addEventListener("pagemode", function (e) { if (PDFViewerApplication.initialized) { var t = e.detail.mode; switch (t) { case "bookmarks": t = "outline"; case "thumbs": case "attachments": PDFViewerApplication.switchSidebarView(t, !0); break; case "none": PDFViewerApplication.sidebarOpen && document.getElementById("sidebarToggle").click() } } }, !0), document.addEventListener("namedaction", function (e) { if (PDFViewerApplication.initialized) switch (e.detail.action) { case "GoToPage": document.getElementById("pageNumber").focus(); break; case "Find": PDFViewerApplication.supportsIntegratedFind || PDFViewerApplication.findBar.toggle() } }, !0), window.addEventListener("presentationmodechanged", function (e) { var t = e.detail.active, i = e.detail.switchInProgress; PDFViewerApplication.pdfViewer.presentationModeState = i ? PresentationModeState.CHANGING : t ? PresentationModeState.FULLSCREEN : PresentationModeState.NORMAL }), window.addEventListener("updateviewarea", function (e) { if (PDFViewerApplication.initialized) { var t = e.location; PDFViewerApplication.store.initializedPromise.then(function () { PDFViewerApplication.store.setMultiple({ exists: !0, page: t.pageNumber, zoom: t.scale, scrollLeft: t.left, scrollTop: t.top }).catch(function () { }) }); var i = PDFViewerApplication.pdfLinkService.getAnchorUrl(t.pdfOpenParams); document.getElementById("viewBookmark").href = i, document.getElementById("secondaryViewBookmark").href = i, PDFViewerApplication.pdfHistory.updateCurrentBookmark(t.pdfOpenParams, t.pageNumber); var n = document.getElementById("pageNumber"); PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1).renderingState === RenderingStates.FINISHED ? n.classList.remove(PAGE_NUMBER_LOADING_INDICATOR) : n.classList.add(PAGE_NUMBER_LOADING_INDICATOR) } }, !0), window.addEventListener("resize", function (e) { if (PDFViewerApplication.initialized) { var t = PDFViewerApplication.pdfViewer.currentScaleValue; "auto" === t || "page-fit" === t || "page-width" === t ? PDFViewerApplication.pdfViewer.currentScaleValue = t : t || (PDFViewerApplication.pdfViewer.currentScaleValue = DEFAULT_SCALE_VALUE), PDFViewerApplication.pdfViewer.update() } SecondaryToolbar.setMaxHeight(document.getElementById("viewerContainer")) }), window.addEventListener("hashchange", function (e) { if (PDFViewerApplication.pdfHistory.isHashChangeUnlocked) { var t = document.location.hash.substring(1); if (!t) return; PDFViewerApplication.isInitialViewSet ? PDFViewerApplication.pdfLinkService.setHash(t) : PDFViewerApplication.initialBookmark = t } }), window.addEventListener("change", function (e) { var t = e.target.files; if (t && 0 !== t.length) { var i = t[0]; if (!PDFJS.disableCreateObjectURL && "undefined" != typeof URL && URL.createObjectURL) PDFViewerApplication.open(URL.createObjectURL(i)); else { var n = new FileReader; n.onload = function (e) { var t = e.target.result, i = new Uint8Array(t); PDFViewerApplication.open(i) }, n.readAsArrayBuffer(i) } PDFViewerApplication.setTitleUsingUrl(i.name), document.getElementById("viewBookmark").setAttribute("hidden", "true"), document.getElementById("secondaryViewBookmark").setAttribute("hidden", "true"), document.getElementById("download").setAttribute("hidden", "true"), document.getElementById("secondaryDownload").setAttribute("hidden", "true") } }, !0), window.addEventListener("localized", function (e) { document.getElementsByTagName("html")[0].dir = mozL10n.getDirection(), PDFViewerApplication.animationStartedPromise.then(function () { var e = document.getElementById("scaleSelectContainer"); if (0 === e.clientWidth && e.setAttribute("style", "display: inherit;"), e.clientWidth > 0) { var t = document.getElementById("scaleSelect"); t.setAttribute("style", "min-width: inherit;"); var i = t.clientWidth + SCALE_SELECT_CONTAINER_PADDING; t.setAttribute("style", "min-width: " + (i + SCALE_SELECT_PADDING) + "px;"), e.setAttribute("style", "min-width: " + i + "px; max-width: " + i + "px;") } SecondaryToolbar.setMaxHeight(document.getElementById("viewerContainer")) }) }, !0), window.addEventListener("scalechange", function (e) { if (document.getElementById("zoomOut").disabled = e.scale === MIN_SCALE, document.getElementById("zoomIn").disabled = e.scale === MAX_SCALE, !selectScaleOption(e.presetValue || "" + e.scale)) { var t = document.getElementById("customScaleOption"), i = Math.round(1e4 * e.scale) / 100; t.textContent = mozL10n.get("page_scale_percent", { scale: i }, "{{scale}}%"), t.selected = !0 } PDFViewerApplication.initialized && PDFViewerApplication.pdfViewer.update() }, !0), window.addEventListener("pagechange", function (e) { var t = e.pageNumber; e.previousPageNumber !== t && (document.getElementById("pageNumber").value = t, PDFViewerApplication.sidebarOpen && PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(t)); var i = PDFViewerApplication.pagesCount; if (document.getElementById("previous").disabled = t <= 1, document.getElementById("next").disabled = t >= i, document.getElementById("firstPage").disabled = t <= 1, document.getElementById("lastPage").disabled = t >= i, PDFJS.pdfBug && Stats.enabled) { var n = PDFViewerApplication.pdfViewer.getPageView(t - 1); n.stats && Stats.add(t, n.stats) } }, !0), window.addEventListener("DOMMouseScroll", handleMouseWheel), window.addEventListener("mousewheel", handleMouseWheel), window.addEventListener("click", function (e) { SecondaryToolbar.opened && PDFViewerApplication.pdfViewer.containsElement(e.target) && SecondaryToolbar.close() }, !1), window.addEventListener("keydown", function (e) { if (!OverlayManager.active) { var t = !1, i = (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0), n = PDFViewerApplication.pdfViewer, s = n && n.isInPresentationMode; if (1 === i || 8 === i || 5 === i || 12 === i) switch (e.keyCode) { case 70: PDFViewerApplication.supportsIntegratedFind || (PDFViewerApplication.findBar.open(), t = !0); break; case 71: PDFViewerApplication.supportsIntegratedFind || (PDFViewerApplication.findBar.dispatchEvent("again", 5 === i || 12 === i), t = !0); break; case 61: case 107: case 187: case 171: s || PDFViewerApplication.zoomIn(), t = !0; break; case 173: case 109: case 189: s || PDFViewerApplication.zoomOut(), t = !0; break; case 48: case 96: s || (setTimeout(function () { n.currentScaleValue = DEFAULT_SCALE_VALUE }), t = !1) } if (1 === i || 8 === i) switch (e.keyCode) { case 83: PDFViewerApplication.download(), t = !0 } if (3 === i || 10 === i) switch (e.keyCode) { case 80: PDFViewerApplication.requestPresentationMode(), t = !0; break; case 71: document.getElementById("pageNumber").select(), t = !0 } if (t) e.preventDefault(); else { var r = document.activeElement || document.querySelector(":focus"), a = r && r.tagName.toUpperCase(); if ("INPUT" !== a && "TEXTAREA" !== a && "SELECT" !== a || 27 === e.keyCode) { var o = !1; if (0 === i) switch (e.keyCode) { case 38: case 33: case 8: if (!s && "page-fit" !== n.currentScaleValue) break; case 37: if (n.isHorizontalScrollbarEnabled) break; case 75: case 80: PDFViewerApplication.page--, t = !0; break; case 27: SecondaryToolbar.opened && (SecondaryToolbar.close(), t = !0), !PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened && (PDFViewerApplication.findBar.close(), t = !0); break; case 40: case 34: case 32: if (!s && "page-fit" !== n.currentScaleValue) break; case 39: if (n.isHorizontalScrollbarEnabled) break; case 74: case 78: PDFViewerApplication.page++, t = !0; break; case 36: (s || PDFViewerApplication.page > 1) && (PDFViewerApplication.page = 1, t = !0, o = !0); break; case 35: (s || PDFViewerApplication.pdfDocument && PDFViewerApplication.page < PDFViewerApplication.pagesCount) && (PDFViewerApplication.page = PDFViewerApplication.pagesCount, t = !0, o = !0); break; case 72: s || HandTool.toggle(); break; case 82: PDFViewerApplication.rotatePages(90) } if (4 === i) switch (e.keyCode) { case 32: if (!s && "page-fit" !== n.currentScaleValue) break; PDFViewerApplication.page--, t = !0; break; case 82: PDFViewerApplication.rotatePages(-90) } if (t || s || (e.keyCode >= 33 && e.keyCode <= 40 || 32 === e.keyCode && "BUTTON" !== a) && (o = !0), 2 === i) switch (e.keyCode) { case 37: s && (PDFViewerApplication.pdfHistory.back(), t = !0); break; case 39: s && (PDFViewerApplication.pdfHistory.forward(), t = !0) } o && !n.containsElement(r) && n.focus(), t && e.preventDefault() } } } }), window.addEventListener("beforeprint", function (e) { PDFViewerApplication.beforePrint() }), window.addEventListener("afterprint", function (e) { PDFViewerApplication.afterPrint() }), PDFViewerApplication.animationStartedPromise = new Promise(function (e) { window.requestAnimationFrame(e) });