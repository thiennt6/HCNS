"undefined" == typeof PDFJS && (("undefined" != typeof window ? window : this).PDFJS = {}), PDFJS.version = "1.2.109", PDFJS.build = "875588d", function () { "use strict"; var t = "undefined" == typeof window ? this : window, e = "undefined" == typeof window, n = [.001, 0, 0, .001, 0, 0], i = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }, r = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }, a = { WIDGET: 1, TEXT: 2, LINK: 3 }, s = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; t.PDFJS || (t.PDFJS = {}), t.PDFJS.pdfBug = !1, PDFJS.VERBOSITY_LEVELS = { errors: 0, warnings: 1, infos: 5 }; var o = PDFJS.OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotations: 78, endAnnotations: 79, beginAnnotation: 80, endAnnotation: 81, paintJpegXObject: 82, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; function l(t) { PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos && console.log("Info: " + t) } function c(t) { PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings && console.log("Warning: " + t) } function h(t) { c("Deprecated API usage: " + t) } function u(t) { throw PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.errors && (console.log("Error: " + t), console.log(function () { try { throw new Error } catch (t) { return t.stack ? t.stack.split("\n").slice(2).join("\n") : "" } }())), A.notify(f.unknown), new Error(t) } function d(t, e) { t || u(e) } var p, f = PDFJS.UNSUPPORTED_FEATURES = { unknown: "unknown", forms: "forms", javaScript: "javaScript", smask: "smask", shadingPattern: "shadingPattern", font: "font" }, A = PDFJS.UnsupportedManager = (p = [], { listen: function (t) { p.push(t) }, notify: function (t) { c('Unsupported feature "' + t + '"'); for (var e = 0, n = p.length; e < n; e++) p[e](t) } }); function g(t, e) { if (!e) return t; if (/^[a-z][a-z0-9+\-.]*:/i.test(e)) return e; var n; if ("/" === e.charAt(0)) return n = t.indexOf("://"), "/" === e.charAt(1) ? ++n : n = t.indexOf("/", n + 3), t.substring(0, n) + e; var i = t.length; i = (n = t.lastIndexOf("#")) >= 0 ? n : i, i = (n = t.lastIndexOf("?", i)) >= 0 ? n : i; var r = t.lastIndexOf("/", i); return t.substring(0, r + 1) + e } function m(t, e, n) { return Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !1 }), n } PDFJS.isValidUrl = function (t, e) { if (!t) return !1; var n = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(t); if (!n) return e; switch (n = n[0].toLowerCase()) { case "http": case "https": case "ftp": case "mailto": case "tel": return !0; default: return !1 } }, PDFJS.shadow = m; var v = PDFJS.LinkTarget = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 }, b = ["", "_self", "_blank", "_parent", "_top"]; function S() { switch (PDFJS.openExternalLinksInNewWindow && (c("PDFJS.openExternalLinksInNewWindow is deprecated, use PDFJS.externalLinkTarget instead."), PDFJS.externalLinkTarget === v.NONE && (PDFJS.externalLinkTarget = v.BLANK), PDFJS.openExternalLinksInNewWindow = !1), PDFJS.externalLinkTarget) { case v.NONE: return !1; case v.SELF: case v.BLANK: case v.PARENT: case v.TOP: return !0 } return c("PDFJS.externalLinkTarget is invalid: " + PDFJS.externalLinkTarget), PDFJS.externalLinkTarget = v.NONE, !1 } PDFJS.isExternalLinkTargetSet = S; var y = PDFJS.PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }, x = function () { function t(t, e) { this.name = "PasswordException", this.message = t, this.code = e } return t.prototype = new Error, t.constructor = t, t }(); PDFJS.PasswordException = x; var P = function () { function t(t, e) { this.name = "UnknownErrorException", this.message = t, this.details = e } return t.prototype = new Error, t.constructor = t, t }(); PDFJS.UnknownErrorException = P; var k = function () { function t(t) { this.name = "InvalidPDFException", this.message = t } return t.prototype = new Error, t.constructor = t, t }(); PDFJS.InvalidPDFException = k; var C = function () { function t(t) { this.name = "MissingPDFException", this.message = t } return t.prototype = new Error, t.constructor = t, t }(); PDFJS.MissingPDFException = C; var F = function () { function t(t, e) { this.name = "UnexpectedResponseException", this.message = t, this.status = e } return t.prototype = new Error, t.constructor = t, t }(); PDFJS.UnexpectedResponseException = F; (function () { function t(t) { this.message = t } t.prototype = new Error, t.prototype.name = "NotImplementedException", t.constructor = t })(), function () { function t(t, e) { this.begin = t, this.end = e, this.message = "Missing data [" + t + ", " + e + ")" } t.prototype = new Error, t.prototype.name = "MissingDataException", t.constructor = t }(), function () { function t(t) { this.message = t } t.prototype = new Error, t.prototype.name = "XRefParseException", t.constructor = t }(); function D(t) { d("string" == typeof t, "Invalid argument for stringToBytes"); for (var e = t.length, n = new Uint8Array(e), i = 0; i < e; ++i) n[i] = 255 & t.charCodeAt(i); return n } Object.defineProperty(PDFJS, "isLittleEndian", { configurable: !0, get: function () { return m(PDFJS, "isLittleEndian", ((t = new Uint8Array(2))[0] = 1, 1 === new Uint16Array(t.buffer)[0])); var t } }), Object.defineProperty(PDFJS, "hasCanvasTypedArrays", { configurable: !0, get: function () { return m(PDFJS, "hasCanvasTypedArrays", ((t = document.createElement("canvas")).width = t.height = 1, void 0 !== t.getContext("2d").createImageData(1, 1).data.buffer)); var t } }); var T = function () { function t(i, r) { this.buffer = i, this.byteLength = i.length, this.length = void 0 === r ? this.byteLength >> 2 : r, function (i) { for (; e < i;) Object.defineProperty(t.prototype, e, n(e)), e++ }(this.length) } t.prototype = Object.create(null); var e = 0; function n(t) { return { get: function () { var e = this.buffer, n = t << 2; return (e[n] | e[n + 1] << 8 | e[n + 2] << 16 | e[n + 3] << 24) >>> 0 }, set: function (e) { var n = this.buffer, i = t << 2; n[i] = 255 & e, n[i + 1] = e >> 8 & 255, n[i + 2] = e >> 16 & 255, n[i + 3] = e >>> 24 & 255 } } } return t }(), w = [1, 0, 0, 1, 0, 0], L = PDFJS.Util = function () { function t() { } var e = ["rgb(", 0, ",", 0, ",", 0, ")"]; return t.makeCssRgb = function (t, n, i) { return e[1] = t, e[3] = n, e[5] = i, e.join("") }, t.transform = function (t, e) { return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], t[0] * e[4] + t[2] * e[5] + t[4], t[1] * e[4] + t[3] * e[5] + t[5]] }, t.applyTransform = function (t, e) { return [t[0] * e[0] + t[1] * e[2] + e[4], t[0] * e[1] + t[1] * e[3] + e[5]] }, t.applyInverseTransform = function (t, e) { var n = e[0] * e[3] - e[1] * e[2]; return [(t[0] * e[3] - t[1] * e[2] + e[2] * e[5] - e[4] * e[3]) / n, (-t[0] * e[1] + t[1] * e[0] + e[4] * e[1] - e[5] * e[0]) / n] }, t.getAxialAlignedBoundingBox = function (e, n) { var i = t.applyTransform(e, n), r = t.applyTransform(e.slice(2, 4), n), a = t.applyTransform([e[0], e[3]], n), s = t.applyTransform([e[2], e[1]], n); return [Math.min(i[0], r[0], a[0], s[0]), Math.min(i[1], r[1], a[1], s[1]), Math.max(i[0], r[0], a[0], s[0]), Math.max(i[1], r[1], a[1], s[1])] }, t.inverseTransform = function (t) { var e = t[0] * t[3] - t[1] * t[2]; return [t[3] / e, -t[1] / e, -t[2] / e, t[0] / e, (t[2] * t[5] - t[4] * t[3]) / e, (t[4] * t[1] - t[5] * t[0]) / e] }, t.apply3dTransform = function (t, e) { return [t[0] * e[0] + t[1] * e[1] + t[2] * e[2], t[3] * e[0] + t[4] * e[1] + t[5] * e[2], t[6] * e[0] + t[7] * e[1] + t[8] * e[2]] }, t.singularValueDecompose2dScale = function (t) { var e = [t[0], t[2], t[1], t[3]], n = t[0] * e[0] + t[1] * e[2], i = t[0] * e[1] + t[1] * e[3], r = t[2] * e[0] + t[3] * e[2], a = t[2] * e[1] + t[3] * e[3], s = (n + a) / 2, o = Math.sqrt((n + a) * (n + a) - 4 * (n * a - r * i)) / 2, l = s + o || 1, c = s - o || 1; return [Math.sqrt(l), Math.sqrt(c)] }, t.normalizeRect = function (t) { var e = t.slice(0); return t[0] > t[2] && (e[0] = t[2], e[2] = t[0]), t[1] > t[3] && (e[1] = t[3], e[3] = t[1]), e }, t.intersect = function (e, n) { function i(t, e) { return t - e } var r = [e[0], e[2], n[0], n[2]].sort(i), a = [e[1], e[3], n[1], n[3]].sort(i), s = []; return e = t.normalizeRect(e), n = t.normalizeRect(n), (r[0] === e[0] && r[1] === n[0] || r[0] === n[0] && r[1] === e[0]) && (s[0] = r[1], s[2] = r[2], (a[0] === e[1] && a[1] === n[1] || a[0] === n[1] && a[1] === e[1]) && (s[1] = a[1], s[3] = a[2], s)) }, t.sign = function (t) { return t < 0 ? -1 : 1 }, t.appendToArray = function (t, e) { Array.prototype.push.apply(t, e) }, t.prependToArray = function (t, e) { Array.prototype.unshift.apply(t, e) }, t.extendObj = function (t, e) { for (var n in e) t[n] = e[n] }, t.getInheritableProperty = function (t, e) { for (; t && !t.has(e) ;) t = t.get("Parent"); return t ? t.get(e) : null }, t.inherit = function (t, e, n) { for (var i in t.prototype = Object.create(e.prototype), t.prototype.constructor = t, n) t.prototype[i] = n[i] }, t.loadScript = function (t, e) { var n = document.createElement("script"), i = !1; n.setAttribute("src", t), e && (n.onload = function () { i || e(), i = !0 }), document.getElementsByTagName("head")[0].appendChild(n) }, t }(); PDFJS.PageViewport = function () { function t(t, e, n, i, r, a) { this.viewBox = t, this.scale = e, this.rotation = n, this.offsetX = i, this.offsetY = r; var s, o, l, c, h, u, d, p, f = (t[2] + t[0]) / 2, A = (t[3] + t[1]) / 2; switch (n = (n %= 360) < 0 ? n + 360 : n) { case 180: s = -1, o = 0, l = 0, c = 1; break; case 90: s = 0, o = 1, l = 1, c = 0; break; case 270: s = 0, o = -1, l = -1, c = 0; break; default: s = 1, o = 0, l = 0, c = -1 } a && (l = -l, c = -c), 0 === s ? (h = Math.abs(A - t[1]) * e + i, u = Math.abs(f - t[0]) * e + r, d = Math.abs(t[3] - t[1]) * e, p = Math.abs(t[2] - t[0]) * e) : (h = Math.abs(f - t[0]) * e + i, u = Math.abs(A - t[1]) * e + r, d = Math.abs(t[2] - t[0]) * e, p = Math.abs(t[3] - t[1]) * e), this.transform = [s * e, o * e, l * e, c * e, h - s * e * f - l * e * A, u - o * e * f - c * e * A], this.width = d, this.height = p, this.fontScale = e } return t.prototype = { clone: function (e) { var n = "scale" in (e = e || {}) ? e.scale : this.scale, i = "rotation" in e ? e.rotation : this.rotation; return new t(this.viewBox.slice(), n, i, this.offsetX, this.offsetY, e.dontFlip) }, convertToViewportPoint: function (t, e) { return L.applyTransform([t, e], this.transform) }, convertToViewportRectangle: function (t) { var e = L.applyTransform([t[0], t[1]], this.transform), n = L.applyTransform([t[2], t[3]], this.transform); return [e[0], e[1], n[0], n[1]] }, convertToPdfPoint: function (t, e) { return L.applyInverseTransform([t, e], this.transform) } }, t }(); function R(t) { return "number" == typeof t } function E(t) { return t instanceof Array } function I(t) { return "object" == typeof t && null !== t && void 0 !== t.byteLength } function _() { var t = {}; return t.promise = new Promise(function (e, n) { t.resolve = e, t.reject = n }), t } PDFJS.createPromiseCapability = _, function () { if (t.Promise) return "function" != typeof t.Promise.all && (t.Promise.all = function (e) { var n, i, r = 0, a = [], s = new t.Promise(function (t, e) { n = t, i = e }); return e.forEach(function (t, e) { r++, t.then(function (t) { a[e] = t, 0 === --r && n(a) }, i) }), 0 === r && n(a), s }), "function" != typeof t.Promise.resolve && (t.Promise.resolve = function (e) { return new t.Promise(function (t) { t(e) }) }), "function" != typeof t.Promise.reject && (t.Promise.reject = function (e) { return new t.Promise(function (t, n) { n(e) }) }), void ("function" != typeof t.Promise.prototype.catch && (t.Promise.prototype.catch = function (e) { return t.Promise.prototype.then(void 0, e) })); var e = 0, n = 2, i = { handlers: [], running: !1, unhandledRejections: [], pendingRejectionCheck: !1, scheduleHandlers: function (t) { t._status !== e && (this.handlers = this.handlers.concat(t._handlers), t._handlers = [], this.running || (this.running = !0, setTimeout(this.runHandlers.bind(this), 0))) }, runHandlers: function () { for (var t = Date.now() + 1; this.handlers.length > 0;) { var e = this.handlers.shift(), i = e.thisPromise._status, r = e.thisPromise._value; try { 1 === i ? "function" == typeof e.onResolve && (r = e.onResolve(r)) : "function" == typeof e.onReject && (r = e.onReject(r), i = 1, e.thisPromise._unhandledRejection && this.removeUnhandeledRejection(e.thisPromise)) } catch (t) { i = n, r = t } if (e.nextPromise._updateStatus(i, r), Date.now() >= t) break } this.handlers.length > 0 ? setTimeout(this.runHandlers.bind(this), 0) : this.running = !1 }, addUnhandledRejection: function (t) { this.unhandledRejections.push({ promise: t, time: Date.now() }), this.scheduleRejectionCheck() }, removeUnhandeledRejection: function (t) { t._unhandledRejection = !1; for (var e = 0; e < this.unhandledRejections.length; e++) this.unhandledRejections[e].promise === t && (this.unhandledRejections.splice(e), e--) }, scheduleRejectionCheck: function () { this.pendingRejectionCheck || (this.pendingRejectionCheck = !0, setTimeout(function () { this.pendingRejectionCheck = !1; for (var t = Date.now(), e = 0; e < this.unhandledRejections.length; e++) if (t - this.unhandledRejections[e].time > 500) { var n = this.unhandledRejections[e].promise._value, i = "Unhandled rejection: " + n; n.stack && (i += "\n" + n.stack), c(i), this.unhandledRejections.splice(e), e-- } this.unhandledRejections.length && this.scheduleRejectionCheck() }.bind(this), 500)) } }; function r(t) { this._status = e, this._handlers = []; try { t.call(this, this._resolve.bind(this), this._reject.bind(this)) } catch (t) { this._reject(t) } } r.all = function (t) { var e, i, a = new r(function (t, n) { e = t, i = n }), s = t.length, o = []; if (0 === s) return e(o), a; function l(t) { a._status !== n && (o = [], i(t)) } for (var c = 0, h = t.length; c < h; ++c) { var u = t[c], d = function (t) { return function (i) { a._status !== n && (o[t] = i, 0 === --s && e(o)) } }(c); r.isPromise(u) ? u.then(d, l) : d(u) } return a }, r.isPromise = function (t) { return t && "function" == typeof t.then }, r.resolve = function (t) { return new r(function (e) { e(t) }) }, r.reject = function (t) { return new r(function (e, n) { n(t) }) }, r.prototype = { _status: null, _value: null, _handlers: null, _unhandledRejection: null, _updateStatus: function (t, e) { 1 !== this._status && this._status !== n && (1 === t && r.isPromise(e) ? e.then(this._updateStatus.bind(this, 1), this._updateStatus.bind(this, n)) : (this._status = t, this._value = e, t === n && 0 === this._handlers.length && (this._unhandledRejection = !0, i.addUnhandledRejection(this)), i.scheduleHandlers(this))) }, _resolve: function (t) { this._updateStatus(1, t) }, _reject: function (t) { this._updateStatus(n, t) }, then: function (t, e) { var n = new r(function (t, e) { this.resolve = t, this.reject = e }); return this._handlers.push({ thisPromise: this, onResolve: t, onReject: e, nextPromise: n }), i.scheduleHandlers(this), n }, catch: function (t) { return this.then(void 0, t) } }, t.Promise = r }(); var M, N = function () { function t(t, e, n) { for (; t.length < n;) t += e; return t } function e() { this.started = {}, this.times = [], this.enabled = !0 } return e.prototype = { time: function (t) { this.enabled && (t in this.started && c("Timer is already running for " + t), this.started[t] = Date.now()) }, timeEnd: function (t) { this.enabled && (t in this.started || c("Timer has not been started for " + t), this.times.push({ name: t, start: this.started[t], end: Date.now() }), delete this.started[t]) }, toString: function () { var e, n, i = this.times, r = "", a = 0; for (e = 0, n = i.length; e < n; ++e) { var s = i[e].name; s.length > a && (a = s.length) } for (e = 0, n = i.length; e < n; ++e) { var o = i[e], l = o.end - o.start; r += t(o.name, " ", a) + " " + l + "ms\n" } return r } }, e }(); function O(t, e) { this.name = t, this.comObj = e, this.callbackIndex = 1, this.postMessageTransfers = !0; var n = this.callbacksCapabilities = {}, i = this.actionHandler = {}; i.console_log = [function (t) { console.log.apply(console, t) }], i.console_error = [function (t) { console.error.apply(console, t) }], i._unsupported_feature = [function (t) { A.notify(t) }], e.onmessage = function (t) { var r = t.data; if (r.isReply) { var a = r.callbackId; if (r.callbackId in n) { var s = n[a]; delete n[a], "error" in r ? s.reject(r.error) : s.resolve(r.data) } else u("Cannot resolve callback " + a) } else if (r.action in i) { var o = i[r.action]; r.callbackId ? Promise.resolve().then(function () { return o[0].call(o[1], r.data) }).then(function (t) { e.postMessage({ isReply: !0, callbackId: r.callbackId, data: t }) }, function (t) { t instanceof Error && (t += ""), e.postMessage({ isReply: !0, callbackId: r.callbackId, error: t }) }) : o[0].call(o[1], r.data) } else u("Unknown action from worker: " + r.action) } } PDFJS.createBlob = function (t, e) { if ("undefined" != typeof Blob) return new Blob([t], { type: e }); var n = new MozBlobBuilder; return n.append(t), n.getBlob(e) }, PDFJS.createObjectURL = (M = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", function (t, e) { if (!PDFJS.disableCreateObjectURL && "undefined" != typeof URL && URL.createObjectURL) { var n = PDFJS.createBlob(t, e); return URL.createObjectURL(n) } for (var i = "data:" + e + ";base64,", r = 0, a = t.length; r < a; r += 3) { var s = 255 & t[r], o = 255 & t[r + 1], l = 255 & t[r + 2]; i += M[s >> 2] + M[(3 & s) << 4 | o >> 4] + M[r + 1 < a ? (15 & o) << 2 | l >> 6 : 64] + M[r + 2 < a ? 63 & l : 64] } return i }), O.prototype = { on: function (t, e, n) { var i = this.actionHandler; i[t] && u('There is already an actionName called "' + t + '"'), i[t] = [e, n] }, send: function (t, e, n) { var i = { action: t, data: e }; this.postMessage(i, n) }, sendWithPromise: function (t, e, n) { var i = this.callbackIndex++, r = { action: t, data: e, callbackId: i }, a = _(); this.callbacksCapabilities[i] = a; try { this.postMessage(r, n) } catch (t) { a.reject(t) } return a.promise }, postMessage: function (t, e) { e && this.postMessageTransfers ? this.comObj.postMessage(t, e) : this.comObj.postMessage(t) } }; PDFJS.maxImageSize = void 0 === PDFJS.maxImageSize ? -1 : PDFJS.maxImageSize, PDFJS.cMapUrl = void 0 === PDFJS.cMapUrl ? null : PDFJS.cMapUrl, PDFJS.cMapPacked = void 0 !== PDFJS.cMapPacked && PDFJS.cMapPacked, PDFJS.disableFontFace = void 0 !== PDFJS.disableFontFace && PDFJS.disableFontFace, PDFJS.imageResourcesPath = void 0 === PDFJS.imageResourcesPath ? "" : PDFJS.imageResourcesPath, PDFJS.disableWorker = void 0 !== PDFJS.disableWorker && PDFJS.disableWorker, PDFJS.workerSrc = void 0 === PDFJS.workerSrc ? null : PDFJS.workerSrc, PDFJS.disableRange = void 0 !== PDFJS.disableRange && PDFJS.disableRange, PDFJS.disableStream = void 0 !== PDFJS.disableStream && PDFJS.disableStream, PDFJS.disableAutoFetch = void 0 !== PDFJS.disableAutoFetch && PDFJS.disableAutoFetch, PDFJS.pdfBug = void 0 !== PDFJS.pdfBug && PDFJS.pdfBug, PDFJS.postMessageTransfers = void 0 === PDFJS.postMessageTransfers || PDFJS.postMessageTransfers, PDFJS.disableCreateObjectURL = void 0 !== PDFJS.disableCreateObjectURL && PDFJS.disableCreateObjectURL, PDFJS.disableWebGL = void 0 === PDFJS.disableWebGL || PDFJS.disableWebGL, PDFJS.disableFullscreen = void 0 !== PDFJS.disableFullscreen && PDFJS.disableFullscreen, PDFJS.useOnlyCssZoom = void 0 !== PDFJS.useOnlyCssZoom && PDFJS.useOnlyCssZoom, PDFJS.verbosity = void 0 === PDFJS.verbosity ? PDFJS.VERBOSITY_LEVELS.warnings : PDFJS.verbosity, PDFJS.maxCanvasPixels = void 0 === PDFJS.maxCanvasPixels ? 16777216 : PDFJS.maxCanvasPixels, PDFJS.openExternalLinksInNewWindow = void 0 !== PDFJS.openExternalLinksInNewWindow && PDFJS.openExternalLinksInNewWindow, PDFJS.externalLinkTarget = void 0 === PDFJS.externalLinkTarget ? PDFJS.LinkTarget.NONE : PDFJS.externalLinkTarget, PDFJS.isEvalSupported = void 0 === PDFJS.isEvalSupported || PDFJS.isEvalSupported, PDFJS.getDocument = function (t, e, n, i) { var r, a, s, o = new j; arguments.length > 1 && h("getDocument is called with pdfDataRangeTransport, passwordCallback or progressCallback argument"), e && (e instanceof J || ((e = Object.create(e)).length = t.length, e.initialData = t.initialData, e.abort || (e.abort = function () { })), (t = Object.create(t)).range = e), o.onPassword = n || null, o.onProgress = i || null, "string" == typeof t ? s = { url: t } : I(t) ? s = { data: t } : t instanceof J ? s = { range: t } : ("object" != typeof t && u("Invalid parameter in getDocument, need either Uint8Array, string or a parameter object"), t.url || t.data || t.range || u("Invalid parameter object: need either .data, .range or .url"), s = t); var l = {}; for (var c in s) if ("url" !== c || "undefined" == typeof window) { if ("range" !== c) if ("data" !== c || s[c] instanceof Uint8Array) l[c] = s[c]; else { var d = s[c]; "string" == typeof d ? l[c] = D(d) : "object" != typeof d || null === d || isNaN(d.length) ? I(d) ? l[c] = new Uint8Array(d) : u("Invalid PDF binary data: either typed array, string or array-like object is expected in the data property.") : l[c] = new Uint8Array(d) } } else l[c] = g(window.location.href, s[c]); return l.rangeChunkSize = s.rangeChunkSize || 65536, r = _(), a = new U(r, s.range), r.promise.then(function () { a.fetchDocument(o, l) }), o._transport = a, o }; var j = function () { function t() { this._capability = _(), this._transport = null, this.onPassword = null, this.onProgress = null } return t.prototype = { get promise() { return this._capability.promise }, destroy: function () { return this._transport.destroy() }, then: function (t, e) { return this.promise.then.apply(this.promise, arguments) } }, t }(), J = function () { function t(t, e) { this.length = t, this.initialData = e, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._readyCapability = _() } return t.prototype = { addRangeListener: function (t) { this._rangeListeners.push(t) }, addProgressListener: function (t) { this._progressListeners.push(t) }, addProgressiveReadListener: function (t) { this._progressiveReadListeners.push(t) }, onDataRange: function (t, e) { for (var n = this._rangeListeners, i = 0, r = n.length; i < r; ++i) n[i](t, e) }, onDataProgress: function (t) { this._readyCapability.promise.then(function () { for (var e = this._progressListeners, n = 0, i = e.length; n < i; ++n) e[n](t) }.bind(this)) }, onDataProgressiveRead: function (t) { this._readyCapability.promise.then(function () { for (var e = this._progressiveReadListeners, n = 0, i = e.length; n < i; ++n) e[n](t) }.bind(this)) }, transportReady: function () { this._readyCapability.resolve() }, requestDataRange: function (t, e) { throw new Error("Abstract method PDFDataRangeTransport.requestDataRange") }, abort: function () { } }, t }(); PDFJS.PDFDataRangeTransport = J; var B = function () { function t(t, e, n) { this.pdfInfo = t, this.transport = e, this.loadingTask = n } return t.prototype = { get numPages() { return this.pdfInfo.numPages }, get fingerprint() { return this.pdfInfo.fingerprint }, getPage: function (t) { return this.transport.getPage(t) }, getPageIndex: function (t) { return this.transport.getPageIndex(t) }, getDestinations: function () { return this.transport.getDestinations() }, getDestination: function (t) { return this.transport.getDestination(t) }, getAttachments: function () { return this.transport.getAttachments() }, getJavaScript: function () { return this.transport.getJavaScript() }, getOutline: function () { return this.transport.getOutline() }, getMetadata: function () { return this.transport.getMetadata() }, getData: function () { return this.transport.getData() }, getDownloadInfo: function () { return this.transport.downloadInfoCapability.promise }, getStats: function () { return this.transport.getStats() }, cleanup: function () { this.transport.startCleanup() }, destroy: function () { return this.transport.destroy() } }, t }(), W = function () { function e(e, n, i) { this.pageIndex = e, this.pageInfo = n, this.transport = i, this.stats = new N, this.stats.enabled = !!t.PDFJS.enableStats, this.commonObjs = i.commonObjs, this.objs = new G, this.cleanupAfterRender = !1, this.pendingCleanup = !1, this.intentStates = {}, this.destroyed = !1 } return e.prototype = { get pageNumber() { return this.pageIndex + 1 }, get rotate() { return this.pageInfo.rotate }, get ref() { return this.pageInfo.ref }, get view() { return this.pageInfo.view }, getViewport: function (t, e) { return arguments.length < 2 && (e = this.rotate), new PDFJS.PageViewport(this.view, t, e, 0, 0) }, getAnnotations: function () { return this.annotationsPromise || (this.annotationsPromise = this.transport.getAnnotations(this.pageIndex)), this.annotationsPromise }, render: function (t) { var e = this.stats; e.time("Overall"), this.pendingCleanup = !1; var n = "print" === t.intent ? "print" : "display"; this.intentStates[n] || (this.intentStates[n] = {}); var i = this.intentStates[n]; i.displayReadyCapability || (i.receivingOperatorList = !0, i.displayReadyCapability = _(), i.operatorList = { fnArray: [], argsArray: [], lastChunk: !1 }, this.stats.time("Page Request"), this.transport.messageHandler.send("RenderPageRequest", { pageIndex: this.pageNumber - 1, intent: n })); var r = new z(o, t, this.objs, this.commonObjs, i.operatorList, this.pageNumber); r.useRequestAnimationFrame = "print" !== n, i.renderTasks || (i.renderTasks = []), i.renderTasks.push(r); var a = r.task; t.continueCallback && (h("render is used with continueCallback parameter"), a.onContinue = t.continueCallback); var s = this; function o(t) { var n = i.renderTasks.indexOf(r); n >= 0 && i.renderTasks.splice(n, 1), s.cleanupAfterRender && (s.pendingCleanup = !0), s._tryCleanup(), t ? r.capability.reject(t) : r.capability.resolve(), e.timeEnd("Rendering"), e.timeEnd("Overall") } return i.displayReadyCapability.promise.then(function (t) { s.pendingCleanup ? o() : (e.time("Rendering"), r.initalizeGraphics(t), r.operatorListChanged()) }, function (t) { o(t) }), a }, getOperatorList: function () { this.intentStates.oplist || (this.intentStates.oplist = {}); var t = this.intentStates.oplist; if (!t.opListReadCapability) { var e = { operatorListChanged: function () { t.operatorList.lastChunk && t.opListReadCapability.resolve(t.operatorList) } }; t.receivingOperatorList = !0, t.opListReadCapability = _(), t.renderTasks = [], t.renderTasks.push(e), t.operatorList = { fnArray: [], argsArray: [], lastChunk: !1 }, this.transport.messageHandler.send("RenderPageRequest", { pageIndex: this.pageIndex, intent: "oplist" }) } return t.opListReadCapability.promise }, getTextContent: function () { return this.transport.messageHandler.sendWithPromise("GetTextContent", { pageIndex: this.pageNumber - 1 }) }, _destroy: function () { this.destroyed = !0, this.transport.pageCache[this.pageIndex] = null; var t = []; return Object.keys(this.intentStates).forEach(function (e) { this.intentStates[e].renderTasks.forEach(function (e) { var n = e.capability.promise.catch(function () { }); t.push(n), e.cancel() }) }, this), this.objs.clear(), this.annotationsPromise = null, this.pendingCleanup = !1, Promise.all(t) }, destroy: function () { h("page destroy method, use cleanup() instead"), this.cleanup() }, cleanup: function () { this.pendingCleanup = !0, this._tryCleanup() }, _tryCleanup: function () { this.pendingCleanup && !Object.keys(this.intentStates).some(function (t) { var e = this.intentStates[t]; return 0 !== e.renderTasks.length || e.receivingOperatorList }, this) && (Object.keys(this.intentStates).forEach(function (t) { delete this.intentStates[t] }, this), this.objs.clear(), this.annotationsPromise = null, this.pendingCleanup = !1) }, _startRenderPage: function (t, e) { var n = this.intentStates[e]; n.displayReadyCapability && n.displayReadyCapability.resolve(t) }, _renderPageChunk: function (t, e) { var n, i, r = this.intentStates[e]; for (n = 0, i = t.length; n < i; n++) r.operatorList.fnArray.push(t.fnArray[n]), r.operatorList.argsArray.push(t.argsArray[n]); for (r.operatorList.lastChunk = t.lastChunk, n = 0; n < r.renderTasks.length; n++) r.renderTasks[n].operatorListChanged(); t.lastChunk && (r.receivingOperatorList = !1, this._tryCleanup()) } }, e }(), U = function () { function e(e, n) { if (this.pdfDataRangeTransport = n, this.workerInitializedCapability = e, this.commonObjs = new G, this.loadingTask = null, this.destroyed = !1, this.destroyCapability = null, this.pageCache = [], this.pagePromises = [], this.downloadInfoCapability = _(), !t.PDFJS.disableWorker && "undefined" != typeof Worker) { var i = PDFJS.workerSrc; i || u("No PDFJS.workerSrc specified"); try { var r = new Worker(i), a = new O("main", r); this.messageHandler = a, a.on("test", function (t) { t && t.supportTypedArray ? (this.worker = r, t.supportTransfers || (PDFJS.postMessageTransfers = !1), this.setupMessageHandler(a), e.resolve()) : this.setupFakeWorker() }.bind(this)); var s = new Uint8Array([PDFJS.postMessageTransfers ? 255 : 0]); try { a.send("test", s, [s.buffer]) } catch (t) { l("Cannot use postMessage transfers"), s[0] = 0, a.send("test", s) } return } catch (t) { l("The worker has been disabled.") } } this.setupFakeWorker() } return e.prototype = { destroy: function () { if (this.destroyCapability) return this.destroyCapability.promise; this.destroyed = !0, this.destroyCapability = _(); var t = []; this.pageCache.forEach(function (e) { e && t.push(e._destroy()) }), this.pageCache = [], this.pagePromises = []; var e = this, n = this.messageHandler.sendWithPromise("Terminate", null); return t.push(n), Promise.all(t).then(function () { rt.clear(), e.worker && e.worker.terminate(), e.pdfDataRangeTransport && (e.pdfDataRangeTransport.abort(), e.pdfDataRangeTransport = null), e.messageHandler = null, e.destroyCapability.resolve() }, this.destroyCapability.reject), this.destroyCapability.promise }, setupFakeWorker: function () { t.PDFJS.disableWorker = !0, PDFJS.fakeWorkerFilesLoadedCapability || (PDFJS.fakeWorkerFilesLoadedCapability = _(), L.loadScript(PDFJS.workerSrc, function () { PDFJS.fakeWorkerFilesLoadedCapability.resolve() })), PDFJS.fakeWorkerFilesLoadedCapability.promise.then(function () { c("Setting up fake worker."); var t = { postMessage: function (e) { t.onmessage({ data: e }) }, terminate: function () { } }, e = new O("main", t); this.setupMessageHandler(e), PDFJS.WorkerMessageHandler.setup(e), this.workerInitializedCapability.resolve() }.bind(this)) }, setupMessageHandler: function (t) { function e(e) { t.send("UpdatePassword", e) } this.messageHandler = t; var n = this.pdfDataRangeTransport; n && (n.addRangeListener(function (e, n) { t.send("OnDataRange", { begin: e, chunk: n }) }), n.addProgressListener(function (e) { t.send("OnDataProgress", { loaded: e }) }), n.addProgressiveReadListener(function (e) { t.send("OnDataRange", { chunk: e }) }), t.on("RequestDataRange", function (t) { n.requestDataRange(t.begin, t.end) }, this)), t.on("GetDoc", function (t) { var e = t.pdfInfo; this.numPages = t.pdfInfo.numPages; var n = this.loadingTask, i = new B(e, this, n); this.pdfDocument = i, n._capability.resolve(i) }, this), t.on("NeedPassword", function (t) { var n = this.loadingTask; if (n.onPassword) return n.onPassword(e, y.NEED_PASSWORD); n._capability.reject(new x(t.message, t.code)) }, this), t.on("IncorrectPassword", function (t) { var n = this.loadingTask; if (n.onPassword) return n.onPassword(e, y.INCORRECT_PASSWORD); n._capability.reject(new x(t.message, t.code)) }, this), t.on("InvalidPDF", function (t) { this.loadingTask._capability.reject(new k(t.message)) }, this), t.on("MissingPDF", function (t) { this.loadingTask._capability.reject(new C(t.message)) }, this), t.on("UnexpectedResponse", function (t) { this.loadingTask._capability.reject(new F(t.message, t.status)) }, this), t.on("UnknownError", function (t) { this.loadingTask._capability.reject(new P(t.message, t.details)) }, this), t.on("DataLoaded", function (t) { this.downloadInfoCapability.resolve(t) }, this), t.on("PDFManagerReady", function (t) { this.pdfDataRangeTransport && this.pdfDataRangeTransport.transportReady() }, this), t.on("StartRenderPage", function (t) { if (!this.destroyed) { var e = this.pageCache[t.pageIndex]; e.stats.timeEnd("Page Request"), e._startRenderPage(t.transparency, t.intent) } }, this), t.on("RenderPageChunk", function (t) { this.destroyed || this.pageCache[t.pageIndex]._renderPageChunk(t.operatorList, t.intent) }, this), t.on("commonobj", function (t) { if (!this.destroyed) { var e = t[0], n = t[1]; if (!this.commonObjs.hasData(e)) switch (n) { case "Font": var i, r = t[2]; if ("error" in r) { var a = r.error; c("Error during font loading: " + a), this.commonObjs.resolve(e, a); break } i = new at(r), rt.bind([i], function (t) { this.commonObjs.resolve(e, i) }.bind(this)); break; case "FontPath": this.commonObjs.resolve(e, t[2]); break; default: a("Got unknown common object type " + n) } } }, this), t.on("obj", function (t) { if (!this.destroyed) { var e, n = t[0], i = t[1], r = t[2], a = this.pageCache[i]; if (!a.objs.hasData(n)) switch (r) { case "JpegStream": (function (t, e, n) { var i = new Image; i.onload = function () { n.resolve(t, i) }, i.onerror = function () { n.resolve(t, null), c("Error during JPEG image loading") }, i.src = e })(n, e = t[3], a.objs); break; case "Image": e = t[3], a.objs.resolve(n, e); e && "data" in e && e.data.length > 8e6 && (a.cleanupAfterRender = !0); break; default: u("Got unknown object type " + r) } } }, this), t.on("DocProgress", function (t) { if (!this.destroyed) { var e = this.loadingTask; e.onProgress && e.onProgress({ loaded: t.loaded, total: t.total }) } }, this), t.on("PageError", function (t) { if (!this.destroyed) { var e = this.pageCache[t.pageNum - 1].intentStates[t.intent]; e.displayReadyCapability ? e.displayReadyCapability.reject(t.error) : u(t.error) } }, this), t.on("JpegDecode", function (t) { if (this.destroyed) return Promise.reject("Worker was terminated"); var e = t[0], n = t[1]; return 3 !== n && 1 !== n ? Promise.reject(new Error("Only 3 components or 1 component can be returned")) : new Promise(function (t, i) { var r = new Image; r.onload = function () { var e = r.width, i = r.height, a = e * i, s = 4 * a, o = new Uint8Array(a * n), l = H(e, i).getContext("2d"); l.drawImage(r, 0, 0); var c, h, u = l.getImageData(0, 0, e, i).data; if (3 === n) for (c = 0, h = 0; c < s; c += 4, h += 3) o[h] = u[c], o[h + 1] = u[c + 1], o[h + 2] = u[c + 2]; else if (1 === n) for (c = 0, h = 0; c < s; c += 4, h++) o[h] = u[c]; t({ data: o, width: e, height: i }) }, r.onerror = function () { i(new Error("JpegDecode failed to load image")) }, r.src = e }) }, this) }, fetchDocument: function (t, e) { if (this.destroyed) return t._capability.reject(new Error("Loading aborted")), void this.destroyCapability.resolve(); this.loadingTask = t, e.disableAutoFetch = PDFJS.disableAutoFetch, e.disableStream = PDFJS.disableStream, e.chunkedViewerLoading = !!this.pdfDataRangeTransport, this.pdfDataRangeTransport && (e.length = this.pdfDataRangeTransport.length, e.initialData = this.pdfDataRangeTransport.initialData), this.messageHandler.send("GetDocRequest", { source: e, disableRange: PDFJS.disableRange, maxImageSize: PDFJS.maxImageSize, cMapUrl: PDFJS.cMapUrl, cMapPacked: PDFJS.cMapPacked, disableFontFace: PDFJS.disableFontFace, disableCreateObjectURL: PDFJS.disableCreateObjectURL, verbosity: PDFJS.verbosity }) }, getData: function () { return this.messageHandler.sendWithPromise("GetData", null) }, getPage: function (t, e) { if (t <= 0 || t > this.numPages || (0 | t) !== t) return Promise.reject(new Error("Invalid page request")); var n = t - 1; if (n in this.pagePromises) return this.pagePromises[n]; var i = this.messageHandler.sendWithPromise("GetPage", { pageIndex: n }).then(function (t) { if (this.destroyed) throw new Error("Transport destroyed"); var e = new W(n, t, this); return this.pageCache[n] = e, e }.bind(this)); return this.pagePromises[n] = i, i }, getPageIndex: function (t) { return this.messageHandler.sendWithPromise("GetPageIndex", { ref: t }) }, getAnnotations: function (t) { return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: t }) }, getDestinations: function () { return this.messageHandler.sendWithPromise("GetDestinations", null) }, getDestination: function (t) { return this.messageHandler.sendWithPromise("GetDestination", { id: t }) }, getAttachments: function () { return this.messageHandler.sendWithPromise("GetAttachments", null) }, getJavaScript: function () { return this.messageHandler.sendWithPromise("GetJavaScript", null) }, getOutline: function () { return this.messageHandler.sendWithPromise("GetOutline", null) }, getMetadata: function () { return this.messageHandler.sendWithPromise("GetMetadata", null).then(function (t) { return { info: t[0], metadata: t[1] ? new PDFJS.Metadata(t[1]) : null } }) }, getStats: function () { return this.messageHandler.sendWithPromise("GetStats", null) }, startCleanup: function () { this.messageHandler.sendWithPromise("Cleanup", null).then(function () { for (var t = 0, e = this.pageCache.length; t < e; t++) { var n = this.pageCache[t]; n && n.cleanup() } this.commonObjs.clear(), rt.clear() }.bind(this)) } }, e }(), G = function () { function t() { this.objs = {} } return t.prototype = { ensureObj: function (t) { if (this.objs[t]) return this.objs[t]; var e = { capability: _(), data: null, resolved: !1 }; return this.objs[t] = e, e }, get: function (t, e) { if (e) return this.ensureObj(t).capability.promise.then(e), null; var n = this.objs[t]; return n && n.resolved || u("Requesting object that isn't resolved yet " + t), n.data }, resolve: function (t, e) { var n = this.ensureObj(t); n.resolved = !0, n.data = e, n.capability.resolve(e) }, isResolved: function (t) { var e = this.objs; return !!e[t] && e[t].resolved }, hasData: function (t) { return this.isResolved(t) }, getData: function (t) { var e = this.objs; return e[t] && e[t].resolved ? e[t].data : null }, clear: function () { this.objs = {} } }, t }(), X = function () { function t(t) { this._internalRenderTask = t, this.onContinue = null } return t.prototype = { get promise() { return this._internalRenderTask.capability.promise }, cancel: function () { this._internalRenderTask.cancel() }, then: function (t, e) { return this.promise.then.apply(this.promise, arguments) } }, t }(), z = function () { function e(t, e, n, i, r, a) { this.callback = t, this.params = e, this.objs = n, this.commonObjs = i, this.operatorListIdx = null, this.operatorList = r, this.pageNumber = a, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this.useRequestAnimationFrame = !1, this.cancelled = !1, this.capability = _(), this.task = new X(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this) } return e.prototype = { initalizeGraphics: function (e) { if (!this.cancelled) { PDFJS.pdfBug && "StepperManager" in t && t.StepperManager.enabled && (this.stepper = t.StepperManager.create(this.pageNumber - 1), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint()); var n = this.params; this.gfx = new Z(n.canvasContext, this.commonObjs, this.objs, n.imageLayer), this.gfx.beginDrawing(n.viewport, e), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback && this.graphicsReadyCallback() } }, cancel: function () { this.running = !1, this.cancelled = !0, this.callback("cancelled") }, operatorListChanged: function () { this.graphicsReady ? (this.stepper && this.stepper.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound) }, _continue: function () { this.running = !0, this.cancelled || (this.task.onContinue ? this.task.onContinue.call(this.task, this._scheduleNextBound) : this._scheduleNext()) }, _scheduleNext: function () { this.useRequestAnimationFrame ? window.requestAnimationFrame(this._nextBound) : Promise.resolve(void 0).then(this._nextBound) }, _next: function () { this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), this.callback()))) } }, e }(), Y = (PDFJS.Metadata = function () { function t(t) { "string" == typeof t ? (t = function (t) { return t.replace(/>\\376\\377([^<]+)/g, function (t, e) { for (var n = e.replace(/\\([0-3])([0-7])([0-7])/g, function (t, e, n, i) { return String.fromCharCode(64 * e + 8 * n + 1 * i) }), i = "", r = 0; r < n.length; r += 2) { var a = 256 * n.charCodeAt(r) + n.charCodeAt(r + 1); i += "&#x" + (65536 + a).toString(16).substring(1) + ";" } return ">" + i }) }(t), t = (new DOMParser).parseFromString(t, "application/xml")) : t instanceof Document || u("Metadata: Invalid metadata object"); this.metaDocument = t, this.metadata = {}, this.parse() } return t.prototype = { parse: function () { var t = this.metaDocument.documentElement; if ("rdf:rdf" !== t.nodeName.toLowerCase()) for (t = t.firstChild; t && "rdf:rdf" !== t.nodeName.toLowerCase() ;) t = t.nextSibling; var e = t ? t.nodeName.toLowerCase() : null; if (t && "rdf:rdf" === e && t.hasChildNodes()) { var n, i, r, a, s, o, l, c = t.childNodes; for (a = 0, o = c.length; a < o; a++) if ("rdf:description" === (n = c[a]).nodeName.toLowerCase()) for (s = 0, l = n.childNodes.length; s < l; s++) "#text" !== n.childNodes[s].nodeName.toLowerCase() && (r = (i = n.childNodes[s]).nodeName.toLowerCase(), this.metadata[r] = i.textContent.trim()) } }, get: function (t) { return this.metadata[t] || null }, has: function (t) { return void 0 !== this.metadata[t] } }, t }(), 16); function H(t, e) { var n = document.createElement("canvas"); return n.width = t, n.height = e, n } function Q(t) { t.mozCurrentTransform || (t._originalSave = t.save, t._originalRestore = t.restore, t._originalRotate = t.rotate, t._originalScale = t.scale, t._originalTranslate = t.translate, t._originalTransform = t.transform, t._originalSetTransform = t.setTransform, t._transformMatrix = t._transformMatrix || [1, 0, 0, 1, 0, 0], t._transformStack = [], Object.defineProperty(t, "mozCurrentTransform", { get: function () { return this._transformMatrix } }), Object.defineProperty(t, "mozCurrentTransformInverse", { get: function () { var t = this._transformMatrix, e = t[0], n = t[1], i = t[2], r = t[3], a = t[4], s = t[5], o = e * r - n * i, l = n * i - e * r; return [r / o, n / l, i / l, e / o, (r * a - i * s) / l, (n * a - e * s) / o] } }), t.save = function () { var t = this._transformMatrix; this._transformStack.push(t), this._transformMatrix = t.slice(0, 6), this._originalSave() }, t.restore = function () { var t = this._transformStack.pop(); t && (this._transformMatrix = t, this._originalRestore()) }, t.translate = function (t, e) { var n = this._transformMatrix; n[4] = n[0] * t + n[2] * e + n[4], n[5] = n[1] * t + n[3] * e + n[5], this._originalTranslate(t, e) }, t.scale = function (t, e) { var n = this._transformMatrix; n[0] = n[0] * t, n[1] = n[1] * t, n[2] = n[2] * e, n[3] = n[3] * e, this._originalScale(t, e) }, t.transform = function (e, n, i, r, a, s) { var o = this._transformMatrix; this._transformMatrix = [o[0] * e + o[2] * n, o[1] * e + o[3] * n, o[0] * i + o[2] * r, o[1] * i + o[3] * r, o[0] * a + o[2] * s + o[4], o[1] * a + o[3] * s + o[5]], t._originalTransform(e, n, i, r, a, s) }, t.setTransform = function (e, n, i, r, a, s) { this._transformMatrix = [e, n, i, r, a, s], t._originalSetTransform(e, n, i, r, a, s) }, t.rotate = function (t) { var e = Math.cos(t), n = Math.sin(t), i = this._transformMatrix; this._transformMatrix = [i[0] * e + i[2] * n, i[1] * e + i[3] * n, i[0] * -n + i[2] * e, i[1] * -n + i[3] * e, i[4], i[5]], this._originalRotate(t) }) } var V, q = (V = {}, { getCanvas: function (t, e, n, i) { var r; if (void 0 !== V[t]) (r = V[t]).canvas.width = e, r.canvas.height = n, r.context.setTransform(1, 0, 0, 1, 0, 0); else { var a = H(e, n), s = a.getContext("2d"); i && Q(s), V[t] = r = { canvas: a, context: s } } return r }, clear: function () { for (var t in V) { var e = V[t]; e.canvas.width = 0, e.canvas.height = 0, delete V[t] } } }); var K = function () { function t(t) { this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = w, this.textMatrixScale = 1, this.fontMatrix = n, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = i.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.old = t } return t.prototype = { clone: function () { return Object.create(this) }, setCurrentPoint: function (t, e) { this.x = t, this.y = e } }, t }(), Z = function () { function t(t, e, n, i) { this.ctx = t, this.current = new K, this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = e, this.objs = n, this.imageLayer = i, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, t && Q(t), this.cachedGetSinglePixelWidth = null } function e(t, e) { if ("undefined" != typeof ImageData && e instanceof ImageData) t.putImageData(e, 0, 0); else { var n, i, a, s, o, l = e.height, c = e.width, h = l % Y, d = (l - h) / Y, p = 0 === h ? d : d + 1, f = t.createImageData(c, Y), A = 0, g = e.data, m = f.data; if (e.kind === r.GRAYSCALE_1BPP) { var v = g.byteLength, b = PDFJS.hasCanvasTypedArrays ? new Uint32Array(m.buffer) : new T(m), S = b.length, y = c + 7 >> 3, x = 4294967295, P = PDFJS.isLittleEndian || !PDFJS.hasCanvasTypedArrays ? 4278190080 : 255; for (i = 0; i < p; i++) { for (s = i < d ? Y : h, n = 0, a = 0; a < s; a++) { for (var k = v - A, C = 0, F = k > y ? c : 8 * k - 7, D = -8 & F, w = 0, L = 0; C < D; C += 8) L = g[A++], b[n++] = 128 & L ? x : P, b[n++] = 64 & L ? x : P, b[n++] = 32 & L ? x : P, b[n++] = 16 & L ? x : P, b[n++] = 8 & L ? x : P, b[n++] = 4 & L ? x : P, b[n++] = 2 & L ? x : P, b[n++] = 1 & L ? x : P; for (; C < F; C++) 0 === w && (L = g[A++], w = 128), b[n++] = L & w ? x : P, w >>= 1 } for (; n < S;) b[n++] = 0; t.putImageData(f, 0, i * Y) } } else if (e.kind === r.RGBA_32BPP) { for (a = 0, o = c * Y * 4, i = 0; i < d; i++) m.set(g.subarray(A, A + o)), A += o, t.putImageData(f, 0, a), a += Y; i < p && (o = c * h * 4, m.set(g.subarray(A, A + o)), t.putImageData(f, 0, a)) } else if (e.kind === r.RGB_24BPP) for (o = c * (s = Y), i = 0; i < p; i++) { for (i >= d && (o = c * (s = h)), n = 0, a = o; a--;) m[n++] = g[A++], m[n++] = g[A++], m[n++] = g[A++], m[n++] = 255; t.putImageData(f, 0, i * Y) } else u("bad image kind: " + e.kind) } } function a(t, e) { for (var n = e.height, i = e.width, r = n % Y, a = (n - r) / Y, s = 0 === r ? a : a + 1, o = t.createImageData(i, Y), l = 0, c = e.data, h = o.data, u = 0; u < s; u++) { for (var d = u < a ? Y : r, p = 3, f = 0; f < d; f++) for (var A = 0, g = 0; g < i; g++) { if (!A) { var m = c[l++]; A = 128 } h[p] = m & A ? 0 : 255, p += 4, A >>= 1 } t.putImageData(o, 0, u * Y) } } function s(t, e) { for (var n = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"], i = 0, r = n.length; i < r; i++) { var a = n[i]; void 0 !== t[a] && (e[a] = t[a]) } void 0 !== t.setLineDash ? (e.setLineDash(t.getLineDash()), e.lineDashOffset = t.lineDashOffset) : void 0 !== t.mozDashOffset && (e.mozDash = t.mozDash, e.mozDashOffset = t.mozDashOffset) } function h(t, e, n, i) { for (var r = t.length, a = 3; a < r; a += 4) { var s = t[a]; if (0 === s) t[a - 3] = e, t[a - 2] = n, t[a - 1] = i; else if (s < 255) { var o = 255 - s; t[a - 3] = t[a - 3] * s + e * o >> 8, t[a - 2] = t[a - 2] * s + n * o >> 8, t[a - 1] = t[a - 1] * s + i * o >> 8 } } } function p(t, e) { for (var n = t.length, i = 3; i < n; i += 4) { var r = t[i]; e[i] = e[i] * r * (1 / 255) | 0 } } function g(t, e) { for (var n = t.length, i = 3; i < n; i += 4) { var r = 77 * t[i - 3] + 152 * t[i - 2] + 28 * t[i - 1]; e[i] = e[i] * r >> 16 } } function v(t, e, n) { var i = e.canvas, r = e.context; t.setTransform(e.scaleX, 0, 0, e.scaleY, e.offsetX, e.offsetY); var a = e.backdrop || null; if ($.isEnabled) { var s = $.composeSMask(n.canvas, i, { subtype: e.subtype, backdrop: a }); return t.setTransform(1, 0, 0, 1, 0, 0), void t.drawImage(s, e.offsetX, e.offsetY) } !function (t, e, n, i, r, a) { var s, o = !!a, l = o ? a[0] : 0, c = o ? a[1] : 0, u = o ? a[2] : 0; s = "Luminosity" === r ? g : p; for (var d = Math.min(i, Math.ceil(1048576 / n)), f = 0; f < i; f += d) { var A = Math.min(d, i - f), m = t.getImageData(0, f, n, A), v = e.getImageData(0, f, n, A); o && h(m.data, l, c, u), s(m.data, v.data), t.putImageData(v, 0, f) } }(r, n, i.width, i.height, e.subtype, a), t.drawImage(i, 0, 0) } var b = ["butt", "round", "square"], S = ["miter", "round", "bevel"], y = {}, x = {}; for (var P in t.prototype = { beginDrawing: function (t, e) { var n = this.ctx.canvas.width, i = this.ctx.canvas.height; e ? this.ctx.clearRect(0, 0, n, i) : (this.ctx.mozOpaque = !0, this.ctx.save(), this.ctx.fillStyle = "rgb(255, 255, 255)", this.ctx.fillRect(0, 0, n, i), this.ctx.restore()); var r = t.transform; this.ctx.save(), this.ctx.transform.apply(this.ctx, r), this.baseTransform = this.ctx.mozCurrentTransform.slice(), this.imageLayer && this.imageLayer.beginLayout() }, executeOperatorList: function (t, e, n, i) { var r = t.argsArray, a = t.fnArray, s = e || 0, l = r.length; if (l === s) return s; for (var c, h = l - s > 10 && "function" == typeof n, u = h ? Date.now() + 15 : 0, d = 0, p = this.commonObjs, f = this.objs; ;) { if (void 0 !== i && s === i.nextBreakPoint) return i.breakIt(s, n), s; if ((c = a[s]) !== o.dependency) this[c].apply(this, r[s]); else for (var A = r[s], g = 0, m = A.length; g < m; g++) { var v = A[g], b = "g" === v[0] && "_" === v[1] ? p : f; if (!b.isResolved(v)) return b.get(v, n), s } if (++s === l) return s; if (h && ++d > 10) { if (Date.now() > u) return n(), s; d = 0 } } }, endDrawing: function () { this.ctx.restore(), q.clear(), $.clear(), this.imageLayer && this.imageLayer.endLayout() }, setLineWidth: function (t) { this.current.lineWidth = t, this.ctx.lineWidth = t }, setLineCap: function (t) { this.ctx.lineCap = b[t] }, setLineJoin: function (t) { this.ctx.lineJoin = S[t] }, setMiterLimit: function (t) { this.ctx.miterLimit = t }, setDash: function (t, e) { var n = this.ctx; void 0 !== n.setLineDash ? (n.setLineDash(t), n.lineDashOffset = e) : (n.mozDash = t, n.mozDashOffset = e) }, setRenderingIntent: function (t) { }, setFlatness: function (t) { }, setGState: function (t) { for (var e = 0, n = t.length; e < n; e++) { var i = t[e], r = i[0], a = i[1]; switch (r) { case "LW": this.setLineWidth(a); break; case "LC": this.setLineCap(a); break; case "LJ": this.setLineJoin(a); break; case "ML": this.setMiterLimit(a); break; case "D": this.setDash(a[0], a[1]); break; case "RI": this.setRenderingIntent(a); break; case "FL": this.setFlatness(a); break; case "Font": this.setFont(a[0], a[1]); break; case "CA": this.current.strokeAlpha = i[1]; break; case "ca": this.current.fillAlpha = i[1], this.ctx.globalAlpha = i[1]; break; case "BM": if (a && a.name && "Normal" !== a.name) { var s = a.name.replace(/([A-Z])/g, function (t) { return "-" + t.toLowerCase() }).substring(1); this.ctx.globalCompositeOperation = s, this.ctx.globalCompositeOperation !== s && c('globalCompositeOperation "' + s + '" is not supported') } else this.ctx.globalCompositeOperation = "source-over"; break; case "SMask": this.current.activeSMask && this.endSMaskGroup(), this.current.activeSMask = a ? this.tempSMask : null, this.current.activeSMask && this.beginSMaskGroup(), this.tempSMask = null } } }, beginSMaskGroup: function () { var t = this.current.activeSMask, e = t.canvas.width, n = t.canvas.height, i = "smaskGroupAt" + this.groupLevel, r = q.getCanvas(i, e, n, !0), a = this.ctx, o = a.mozCurrentTransform; this.ctx.save(); var l = r.context; l.scale(1 / t.scaleX, 1 / t.scaleY), l.translate(-t.offsetX, -t.offsetY), l.transform.apply(l, o), s(a, l), this.ctx = l, this.setGState([["BM", "Normal"], ["ca", 1], ["CA", 1]]), this.groupStack.push(a), this.groupLevel++ }, endSMaskGroup: function () { var t = this.ctx; this.groupLevel--, this.ctx = this.groupStack.pop(), v(this.ctx, this.current.activeSMask, t), this.ctx.restore() }, save: function () { this.ctx.save(); var t = this.current; this.stateStack.push(t), this.current = t.clone(), this.current.activeSMask = null }, restore: function () { 0 !== this.stateStack.length && (null !== this.current.activeSMask && this.endSMaskGroup(), this.current = this.stateStack.pop(), this.ctx.restore(), this.pendingClip = null, this.cachedGetSinglePixelWidth = null) }, transform: function (t, e, n, i, r, a) { this.ctx.transform(t, e, n, i, r, a), this.cachedGetSinglePixelWidth = null }, constructPath: function (t, e) { for (var n = this.ctx, i = this.current, r = i.x, a = i.y, s = 0, l = 0, c = t.length; s < c; s++) switch (0 | t[s]) { case o.rectangle: r = e[l++], a = e[l++]; var h = e[l++], u = e[l++]; 0 === h && (h = this.getSinglePixelWidth()), 0 === u && (u = this.getSinglePixelWidth()); var d = r + h, p = a + u; this.ctx.moveTo(r, a), this.ctx.lineTo(d, a), this.ctx.lineTo(d, p), this.ctx.lineTo(r, p), this.ctx.lineTo(r, a), this.ctx.closePath(); break; case o.moveTo: r = e[l++], a = e[l++], n.moveTo(r, a); break; case o.lineTo: r = e[l++], a = e[l++], n.lineTo(r, a); break; case o.curveTo: r = e[l + 4], a = e[l + 5], n.bezierCurveTo(e[l], e[l + 1], e[l + 2], e[l + 3], r, a), l += 6; break; case o.curveTo2: n.bezierCurveTo(r, a, e[l], e[l + 1], e[l + 2], e[l + 3]), r = e[l + 2], a = e[l + 3], l += 4; break; case o.curveTo3: r = e[l + 2], a = e[l + 3], n.bezierCurveTo(e[l], e[l + 1], r, a, r, a), l += 4; break; case o.closePath: n.closePath() } i.setCurrentPoint(r, a) }, closePath: function () { this.ctx.closePath() }, stroke: function (t) { t = void 0 === t || t; var e = this.ctx, n = this.current.strokeColor; e.lineWidth = Math.max(.65 * this.getSinglePixelWidth(), this.current.lineWidth), e.globalAlpha = this.current.strokeAlpha, n && n.hasOwnProperty("type") && "Pattern" === n.type ? (e.save(), e.strokeStyle = n.getPattern(e, this), e.stroke(), e.restore()) : e.stroke(), t && this.consumePath(), e.globalAlpha = this.current.fillAlpha }, closeStroke: function () { this.closePath(), this.stroke() }, fill: function (t) { t = void 0 === t || t; var e = this.ctx, n = this.current.fillColor, i = !1; this.current.patternFill && (e.save(), e.fillStyle = n.getPattern(e, this), i = !0), this.pendingEOFill ? (void 0 !== e.mozFillRule ? (e.mozFillRule = "evenodd", e.fill(), e.mozFillRule = "nonzero") : e.fill("evenodd"), this.pendingEOFill = !1) : e.fill(), i && e.restore(), t && this.consumePath() }, eoFill: function () { this.pendingEOFill = !0, this.fill() }, fillStroke: function () { this.fill(!1), this.stroke(!1), this.consumePath() }, eoFillStroke: function () { this.pendingEOFill = !0, this.fillStroke() }, closeFillStroke: function () { this.closePath(), this.fillStroke() }, closeEOFillStroke: function () { this.pendingEOFill = !0, this.closePath(), this.fillStroke() }, endPath: function () { this.consumePath() }, clip: function () { this.pendingClip = y }, eoClip: function () { this.pendingClip = x }, beginText: function () { this.current.textMatrix = w, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0 }, endText: function () { var t = this.pendingTextPaths, e = this.ctx; if (void 0 !== t) { e.save(), e.beginPath(); for (var n = 0; n < t.length; n++) { var i = t[n]; e.setTransform.apply(e, i.transform), e.translate(i.x, i.y), i.addToPath(e, i.fontSize) } e.restore(), e.clip(), e.beginPath(), delete this.pendingTextPaths } else e.beginPath() }, setCharSpacing: function (t) { this.current.charSpacing = t }, setWordSpacing: function (t) { this.current.wordSpacing = t }, setHScale: function (t) { this.current.textHScale = t / 100 }, setLeading: function (t) { this.current.leading = -t }, setFont: function (t, e) { var i = this.commonObjs.get(t), r = this.current; if (i || u("Can't find font for " + t), r.fontMatrix = i.fontMatrix ? i.fontMatrix : n, 0 !== r.fontMatrix[0] && 0 !== r.fontMatrix[3] || c("Invalid font matrix for font " + t), e < 0 ? (e = -e, r.fontDirection = -1) : r.fontDirection = 1, this.current.font = i, this.current.fontSize = e, !i.isType3Font) { var a = i.loadedName || "sans-serif", s = i.black ? i.bold ? "900" : "bold" : i.bold ? "bold" : "normal", o = i.italic ? "italic" : "normal", l = '"' + a + '", ' + i.fallbackName, h = e < 16 ? 16 : e > 100 ? 100 : e; this.current.fontSizeScale = e / h; var d = o + " " + s + " " + h + "px " + l; this.ctx.font = d } }, setTextRenderingMode: function (t) { this.current.textRenderingMode = t }, setTextRise: function (t) { this.current.textRise = t }, moveText: function (t, e) { this.current.x = this.current.lineX += t, this.current.y = this.current.lineY += e }, setLeadingMoveText: function (t, e) { this.setLeading(-e), this.moveText(t, e) }, setTextMatrix: function (t, e, n, i, r, a) { this.current.textMatrix = [t, e, n, i, r, a], this.current.textMatrixScale = Math.sqrt(t * t + e * e), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0 }, nextLine: function () { this.moveText(0, this.current.leading) }, paintChar: function (t, e, n) { var r, a = this.ctx, s = this.current, o = s.font, l = s.textRenderingMode, c = s.fontSize / s.fontSizeScale, h = l & i.FILL_STROKE_MASK, u = !!(l & i.ADD_TO_PATH_FLAG); ((o.disableFontFace || u) && (r = o.getPathGenerator(this.commonObjs, t)), o.disableFontFace ? (a.save(), a.translate(e, n), a.beginPath(), r(a, c), h !== i.FILL && h !== i.FILL_STROKE || a.fill(), h !== i.STROKE && h !== i.FILL_STROKE || a.stroke(), a.restore()) : (h !== i.FILL && h !== i.FILL_STROKE || a.fillText(t, e, n), h !== i.STROKE && h !== i.FILL_STROKE || a.strokeText(t, e, n)), u) && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({ transform: a.mozCurrentTransform, x: e, y: n, fontSize: c, addToPath: r }) }, get isFontSubpixelAAEnabled() { var t = document.createElement("canvas").getContext("2d"); t.scale(1.5, 1), t.fillText("I", 0, 10); for (var e = t.getImageData(0, 0, 10, 10).data, n = !1, i = 3; i < e.length; i += 4) if (e[i] > 0 && e[i] < 255) { n = !0; break } return m(this, "isFontSubpixelAAEnabled", n) }, showText: function (t) { var e = this.current, n = e.font; if (n.isType3Font) return this.showType3Text(t); var r = e.fontSize; if (0 !== r) { var a = this.ctx, s = e.fontSizeScale, o = e.charSpacing, l = e.wordSpacing, c = e.fontDirection, h = e.textHScale * c, u = t.length, d = n.vertical, p = d ? 1 : -1, f = n.defaultVMetrics, A = r * e.fontMatrix[0], g = e.textRenderingMode === i.FILL && !n.disableFontFace; a.save(), a.transform.apply(a, e.textMatrix), a.translate(e.x, e.y + e.textRise), c > 0 ? a.scale(h, -1) : a.scale(h, 1); var m = e.lineWidth, v = e.textMatrixScale; if (0 === v || 0 === m) { var b = e.textRenderingMode & i.FILL_STROKE_MASK; b !== i.STROKE && b !== i.FILL_STROKE || (this.cachedGetSinglePixelWidth = null, m = .65 * this.getSinglePixelWidth()) } else m /= v; 1 !== s && (a.scale(s, s), m /= s), a.lineWidth = m; var S, y = 0; for (S = 0; S < u; ++S) { var x = t[S]; if (R(x)) y += p * x * r / 1e3; else { var P, k, C, F, D, T, w, L = !1, E = (x.isSpace ? l : 0) + o, I = x.fontChar, _ = x.accent, M = x.width; if (d) D = x.vmetric || f, T = -(T = x.vmetric ? D[1] : .5 * M) * A, w = D[2] * A, M = D ? -D[0] : M, P = T / s, k = (y + w) / s; else P = y / s, k = 0; if (n.remeasure && M > 0 && this.isFontSubpixelAAEnabled) { var N = M / (1e3 * a.measureText(I).width / r * s); L = !0, a.save(), a.scale(N, 1), P /= N } g && !_ ? a.fillText(I, P, k) : (this.paintChar(I, P, k), _ && (C = P + _.offset.x / s, F = k - _.offset.y / s, this.paintChar(_.fontChar, C, F))), y += M * A + E * c, L && a.restore() } } d ? e.y -= y * h : e.x += y * h, a.restore() } }, showType3Text: function (t) { var e, r, a, s, o = this.ctx, l = this.current, h = l.font, u = l.fontSize, d = l.fontDirection, p = h.vertical ? 1 : -1, f = l.charSpacing, A = l.wordSpacing, g = l.textHScale * d, m = l.fontMatrix || n, v = t.length; if (!(l.textRenderingMode === i.INVISIBLE) && 0 !== u) { for (this.cachedGetSinglePixelWidth = null, o.save(), o.transform.apply(o, l.textMatrix), o.translate(l.x, l.y), o.scale(g, d), e = 0; e < v; ++e) if (R(r = t[e])) s = p * r * u / 1e3, this.ctx.translate(s, 0), l.x += s * g; else { var b = (r.isSpace ? A : 0) + f, S = h.charProcOperatorList[r.operatorListId]; if (S) this.processingType3 = r, this.save(), o.scale(u, u), o.transform.apply(o, m), this.executeOperatorList(S), this.restore(), a = L.applyTransform([r.width, 0], m)[0] * u + b, o.translate(a, 0), l.x += a * g; else c('Type3 character "' + r.operatorListId + '" is not available') } o.restore(), this.processingType3 = null } }, setCharWidth: function (t, e) { }, setCharWidthAndBounds: function (t, e, n, i, r, a) { this.ctx.rect(n, i, r - n, a - i), this.clip(), this.endPath() }, getColorN_Pattern: function (t) { var e; if ("TilingPattern" === t[0]) { var n = t[1], i = this.baseTransform || this.ctx.mozCurrentTransform.slice(); e = new it(t, n, this.ctx, this.objs, this.commonObjs, i) } else e = nt(t); return e }, setStrokeColorN: function () { this.current.strokeColor = this.getColorN_Pattern(arguments) }, setFillColorN: function () { this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0 }, setStrokeRGBColor: function (t, e, n) { var i = L.makeCssRgb(t, e, n); this.ctx.strokeStyle = i, this.current.strokeColor = i }, setFillRGBColor: function (t, e, n) { var i = L.makeCssRgb(t, e, n); this.ctx.fillStyle = i, this.current.fillColor = i, this.current.patternFill = !1 }, shadingFill: function (t) { var e = this.ctx; this.save(); var n = nt(t); e.fillStyle = n.getPattern(e, this, !0); var i = e.mozCurrentTransformInverse; if (i) { var r = e.canvas, a = r.width, s = r.height, o = L.applyTransform([0, 0], i), l = L.applyTransform([0, s], i), c = L.applyTransform([a, 0], i), h = L.applyTransform([a, s], i), u = Math.min(o[0], l[0], c[0], h[0]), d = Math.min(o[1], l[1], c[1], h[1]), p = Math.max(o[0], l[0], c[0], h[0]), f = Math.max(o[1], l[1], c[1], h[1]); this.ctx.fillRect(u, d, p - u, f - d) } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10); this.restore() }, beginInlineImage: function () { u("Should not call beginInlineImage") }, beginImageData: function () { u("Should not call beginImageData") }, paintFormXObjectBegin: function (t, e) { if (this.save(), this.baseTransformStack.push(this.baseTransform), E(t) && 6 === t.length && this.transform.apply(this, t), this.baseTransform = this.ctx.mozCurrentTransform, E(e) && 4 === e.length) { var n = e[2] - e[0], i = e[3] - e[1]; this.ctx.rect(e[0], e[1], n, i), this.clip(), this.endPath() } }, paintFormXObjectEnd: function () { this.restore(), this.baseTransform = this.baseTransformStack.pop() }, beginGroup: function (t) { this.save(); var e = this.ctx; t.isolated || l("TODO: Support non-isolated groups."), t.knockout && c("Knockout groups not supported."); var n = e.mozCurrentTransform; t.matrix && e.transform.apply(e, t.matrix), d(t.bbox, "Bounding box is required."); var i = L.getAxialAlignedBoundingBox(t.bbox, e.mozCurrentTransform), r = [0, 0, e.canvas.width, e.canvas.height]; i = L.intersect(i, r) || [0, 0, 0, 0]; var a = Math.floor(i[0]), o = Math.floor(i[1]), h = Math.max(Math.ceil(i[2]) - a, 1), u = Math.max(Math.ceil(i[3]) - o, 1), p = 1, f = 1; h > 4096 && (p = h / 4096, h = 4096), u > 4096 && (f = u / 4096, u = 4096); var A = "groupAt" + this.groupLevel; t.smask && (A += "_smask_" + this.smaskCounter++ % 2); var g = q.getCanvas(A, h, u, !0), m = g.context; m.scale(1 / p, 1 / f), m.translate(-a, -o), m.transform.apply(m, n), t.smask ? this.smaskStack.push({ canvas: g.canvas, context: m, offsetX: a, offsetY: o, scaleX: p, scaleY: f, subtype: t.smask.subtype, backdrop: t.smask.backdrop }) : (e.setTransform(1, 0, 0, 1, 0, 0), e.translate(a, o), e.scale(p, f)), s(e, m), this.ctx = m, this.setGState([["BM", "Normal"], ["ca", 1], ["CA", 1]]), this.groupStack.push(e), this.groupLevel++ }, endGroup: function (t) { this.groupLevel--; var e = this.ctx; this.ctx = this.groupStack.pop(), void 0 !== this.ctx.imageSmoothingEnabled ? this.ctx.imageSmoothingEnabled = !1 : this.ctx.mozImageSmoothingEnabled = !1, t.smask ? this.tempSMask = this.smaskStack.pop() : this.ctx.drawImage(e.canvas, 0, 0), this.restore() }, beginAnnotations: function () { this.save(), this.current = new K }, endAnnotations: function () { this.restore() }, beginAnnotation: function (t, e, n) { if (this.save(), E(t) && 4 === t.length) { var i = t[2] - t[0], r = t[3] - t[1]; this.ctx.rect(t[0], t[1], i, r), this.clip(), this.endPath() } this.transform.apply(this, e), this.transform.apply(this, n) }, endAnnotation: function () { this.restore() }, paintJpegXObject: function (t, e, n) { var i = this.objs.get(t); if (i) { this.save(); var r = this.ctx; if (r.scale(1 / e, -1 / n), r.drawImage(i, 0, 0, i.width, i.height, 0, -n, e, n), this.imageLayer) { var a = r.mozCurrentTransformInverse, s = this.getCanvasPosition(0, 0); this.imageLayer.appendImage({ objId: t, left: s[0], top: s[1], width: e / a[0], height: n / a[3] }) } this.restore() } else c("Dependent image isn't ready yet") }, paintImageMaskXObject: function (t) { var e = this.ctx, n = t.width, i = t.height, r = this.current.fillColor, s = this.current.patternFill, o = this.processingType3; if (o && void 0 === o.compiled && (o.compiled = n <= 1e3 && i <= 1e3 ? function (t) { var e, n, i, r, a = t.width, s = t.height, o = a + 1, l = new Uint8Array(o * (s + 1)), c = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), h = a + 7 & -8, u = t.data, d = new Uint8Array(h * s), p = 0; for (e = 0, r = u.length; e < r; e++) for (var f = 128, A = u[e]; f > 0;) d[p++] = A & f ? 0 : 255, f >>= 1; var g = 0; for (0 !== d[p = 0] && (l[0] = 1, ++g), n = 1; n < a; n++) d[p] !== d[p + 1] && (l[n] = d[p] ? 2 : 1, ++g), p++; for (0 !== d[p] && (l[n] = 2, ++g), e = 1; e < s; e++) { i = e * o, d[(p = e * h) - h] !== d[p] && (l[i] = d[p] ? 1 : 8, ++g); var m = (d[p] ? 4 : 0) + (d[p - h] ? 8 : 0); for (n = 1; n < a; n++) c[m = (m >> 2) + (d[p + 1] ? 4 : 0) + (d[p - h + 1] ? 8 : 0)] && (l[i + n] = c[m], ++g), p++; if (d[p - h] !== d[p] && (l[i + n] = d[p] ? 2 : 4, ++g), g > 1e3) return null } for (i = e * o, 0 !== d[p = h * (s - 1)] && (l[i] = 8, ++g), n = 1; n < a; n++) d[p] !== d[p + 1] && (l[i + n] = d[p] ? 4 : 8, ++g), p++; if (0 !== d[p] && (l[i + n] = 4, ++g), g > 1e3) return null; var v = new Int32Array([0, o, -1, 0, -o, 0, 0, 0, 1]), b = []; for (e = 0; g && e <= s; e++) { for (var S = e * o, y = S + a; S < y && !l[S];) S++; if (S !== y) { var x, P = [S % o, e], k = l[S], C = S; do { var F = v[k]; do { S += F } while (!l[S]); 5 !== (x = l[S]) && 10 !== x ? (k = x, l[S] = 0) : (k = x & 51 * k >> 4, l[S] &= k >> 2 | k << 2), P.push(S % o), P.push(S / o | 0), --g } while (C !== S); b.push(P), --e } } return function (t) { t.save(), t.scale(1 / a, -1 / s), t.translate(0, -s), t.beginPath(); for (var e = 0, n = b.length; e < n; e++) { var i = b[e]; t.moveTo(i[0], i[1]); for (var r = 2, o = i.length; r < o; r += 2) t.lineTo(i[r], i[r + 1]) } t.fill(), t.beginPath(), t.restore() } }({ data: t.data, width: n, height: i }) : null), o && o.compiled) o.compiled(e); else { var l = q.getCanvas("maskCanvas", n, i), c = l.context; c.save(), a(c, t), c.globalCompositeOperation = "source-in", c.fillStyle = s ? r.getPattern(c, this) : r, c.fillRect(0, 0, n, i), c.restore(), this.paintInlineImageXObject(l.canvas) } }, paintImageMaskXObjectRepeat: function (t, e, n, i) { var r = t.width, s = t.height, o = this.current.fillColor, l = this.current.patternFill, c = q.getCanvas("maskCanvas", r, s), h = c.context; h.save(), a(h, t), h.globalCompositeOperation = "source-in", h.fillStyle = l ? o.getPattern(h, this) : o, h.fillRect(0, 0, r, s), h.restore(); for (var u = this.ctx, d = 0, p = i.length; d < p; d += 2) u.save(), u.transform(e, 0, 0, n, i[d], i[d + 1]), u.scale(1, -1), u.drawImage(c.canvas, 0, 0, r, s, 0, -1, 1, 1), u.restore() }, paintImageMaskXObjectGroup: function (t) { for (var e = this.ctx, n = this.current.fillColor, i = this.current.patternFill, r = 0, s = t.length; r < s; r++) { var o = t[r], l = o.width, c = o.height, h = q.getCanvas("maskCanvas", l, c), u = h.context; u.save(), a(u, o), u.globalCompositeOperation = "source-in", u.fillStyle = i ? n.getPattern(u, this) : n, u.fillRect(0, 0, l, c), u.restore(), e.save(), e.transform.apply(e, o.transform), e.scale(1, -1), e.drawImage(h.canvas, 0, 0, l, c, 0, -1, 1, 1), e.restore() } }, paintImageXObject: function (t) { var e = this.objs.get(t); e ? this.paintInlineImageXObject(e) : c("Dependent image isn't ready yet") }, paintImageXObjectRepeat: function (t, e, n, i) { var r = this.objs.get(t); if (r) { for (var a = r.width, s = r.height, o = [], l = 0, h = i.length; l < h; l += 2) o.push({ transform: [e, 0, 0, n, i[l], i[l + 1]], x: 0, y: 0, w: a, h: s }); this.paintInlineImageXObjectGroup(r, o) } else c("Dependent image isn't ready yet") }, paintInlineImageXObject: function (t) { var n = t.width, i = t.height, r = this.ctx; this.save(), r.scale(1 / n, -1 / i); var a, s, o = r.mozCurrentTransformInverse, l = o[0], c = o[1], h = Math.max(Math.sqrt(l * l + c * c), 1), u = o[2], d = o[3], p = Math.max(Math.sqrt(u * u + d * d), 1); if (t instanceof HTMLElement || !t.data) a = t; else { var f = (s = q.getCanvas("inlineImage", n, i)).context; e(f, t), a = s.canvas } for (var A = n, g = i, m = "prescale1"; h > 2 && A > 1 || p > 2 && g > 1;) { var v = A, b = g; h > 2 && A > 1 && (h /= A / (v = Math.ceil(A / 2))), p > 2 && g > 1 && (p /= g / (b = Math.ceil(g / 2))), (f = (s = q.getCanvas(m, v, b)).context).clearRect(0, 0, v, b), f.drawImage(a, 0, 0, A, g, 0, 0, v, b), a = s.canvas, A = v, g = b, m = "prescale1" === m ? "prescale2" : "prescale1" } if (r.drawImage(a, 0, 0, A, g, 0, -i, n, i), this.imageLayer) { var S = this.getCanvasPosition(0, -i); this.imageLayer.appendImage({ imgData: t, left: S[0], top: S[1], width: n / o[0], height: i / o[3] }) } this.restore() }, paintInlineImageXObjectGroup: function (t, n) { var i = this.ctx, r = t.width, a = t.height, s = q.getCanvas("inlineImage", r, a); e(s.context, t); for (var o = 0, l = n.length; o < l; o++) { var c = n[o]; if (i.save(), i.transform.apply(i, c.transform), i.scale(1, -1), i.drawImage(s.canvas, c.x, c.y, c.w, c.h, 0, -1, 1, 1), this.imageLayer) { var h = this.getCanvasPosition(c.x, c.y); this.imageLayer.appendImage({ imgData: t, left: h[0], top: h[1], width: r, height: a }) } i.restore() } }, paintSolidColorImageMask: function () { this.ctx.fillRect(0, 0, 1, 1) }, paintXObject: function () { A.notify(f.unknown), c("Unsupported 'paintXObject' command.") }, markPoint: function (t) { }, markPointProps: function (t, e) { }, beginMarkedContent: function (t) { }, beginMarkedContentProps: function (t, e) { }, endMarkedContent: function () { }, beginCompat: function () { }, endCompat: function () { }, consumePath: function () { var t = this.ctx; this.pendingClip && (this.pendingClip === x ? void 0 !== t.mozFillRule ? (t.mozFillRule = "evenodd", t.clip(), t.mozFillRule = "nonzero") : t.clip("evenodd") : t.clip(), this.pendingClip = null), t.beginPath() }, getSinglePixelWidth: function (t) { if (null === this.cachedGetSinglePixelWidth) { var e = this.ctx.mozCurrentTransformInverse; this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1], e[2] * e[2] + e[3] * e[3])) } return this.cachedGetSinglePixelWidth }, getCanvasPosition: function (t, e) { var n = this.ctx.mozCurrentTransform; return [n[0] * t + n[2] * e + n[4], n[1] * t + n[3] * e + n[5]] } }, o) t.prototype[o[P]] = t.prototype[P]; return t }(), $ = function () { function t(t, e, n) { var i = t.createShader(n); if (t.shaderSource(i, e), t.compileShader(i), !t.getShaderParameter(i, t.COMPILE_STATUS)) { var r = t.getShaderInfoLog(i); throw new Error("Error during shader compilation: " + r) } return i } function e(e, n) { return t(e, n, e.VERTEX_SHADER) } function n(e, n) { return t(e, n, e.FRAGMENT_SHADER) } function i(t, e) { for (var n = t.createProgram(), i = 0, r = e.length; i < r; ++i) t.attachShader(n, e[i]); if (t.linkProgram(n), !t.getProgramParameter(n, t.LINK_STATUS)) { var a = t.getProgramInfoLog(n); throw new Error("Error during program linking: " + a) } return n } function r(t, e, n) { t.activeTexture(n); var i = t.createTexture(); return t.bindTexture(t.TEXTURE_2D, i), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), i } var a, s; function o() { a || (s = document.createElement("canvas"), a = s.getContext("webgl", { premultipliedalpha: !1 })) } var l = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ", c = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ", h = null; var u = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ", d = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ", p = null; return { get isEnabled() { if (PDFJS.disableWebGL) return !1; var t = !1; try { o(), t = !!a } catch (t) { } return m(this, "isEnabled", t) }, composeSMask: function (t, u, d) { var p = t.width, f = t.height; h || function () { var t, r; o(), t = s, s = null, r = a, a = null; var u = i(r, [e(r, l), n(r, c)]); r.useProgram(u); var d = {}; d.gl = r, d.canvas = t, d.resolutionLocation = r.getUniformLocation(u, "u_resolution"), d.positionLocation = r.getAttribLocation(u, "a_position"), d.backdropLocation = r.getUniformLocation(u, "u_backdrop"), d.subtypeLocation = r.getUniformLocation(u, "u_subtype"); var p = r.getAttribLocation(u, "a_texCoord"), f = r.getUniformLocation(u, "u_image"), A = r.getUniformLocation(u, "u_mask"), g = r.createBuffer(); r.bindBuffer(r.ARRAY_BUFFER, g), r.bufferData(r.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), r.STATIC_DRAW), r.enableVertexAttribArray(p), r.vertexAttribPointer(p, 2, r.FLOAT, !1, 0, 0), r.uniform1i(f, 0), r.uniform1i(A, 1), h = d }(); var A = h, g = A.canvas, m = A.gl; g.width = p, g.height = f, m.viewport(0, 0, m.drawingBufferWidth, m.drawingBufferHeight), m.uniform2f(A.resolutionLocation, p, f), d.backdrop ? m.uniform4f(A.resolutionLocation, d.backdrop[0], d.backdrop[1], d.backdrop[2], 1) : m.uniform4f(A.resolutionLocation, 0, 0, 0, 0), m.uniform1i(A.subtypeLocation, "Luminosity" === d.subtype ? 1 : 0); var v = r(m, t, m.TEXTURE0), b = r(m, u, m.TEXTURE1), S = m.createBuffer(); return m.bindBuffer(m.ARRAY_BUFFER, S), m.bufferData(m.ARRAY_BUFFER, new Float32Array([0, 0, p, 0, 0, f, 0, f, p, 0, p, f]), m.STATIC_DRAW), m.enableVertexAttribArray(A.positionLocation), m.vertexAttribPointer(A.positionLocation, 2, m.FLOAT, !1, 0, 0), m.clearColor(0, 0, 0, 0), m.enable(m.BLEND), m.blendFunc(m.ONE, m.ONE_MINUS_SRC_ALPHA), m.clear(m.COLOR_BUFFER_BIT), m.drawArrays(m.TRIANGLES, 0, 6), m.flush(), m.deleteTexture(v), m.deleteTexture(b), m.deleteBuffer(S), g }, drawFigures: function (t, r, l, c, h) { p || function () { var t, r; o(), t = s, s = null, r = a, a = null; var l = i(r, [e(r, u), n(r, d)]); r.useProgram(l); var c = {}; c.gl = r, c.canvas = t, c.resolutionLocation = r.getUniformLocation(l, "u_resolution"), c.scaleLocation = r.getUniformLocation(l, "u_scale"), c.offsetLocation = r.getUniformLocation(l, "u_offset"), c.positionLocation = r.getAttribLocation(l, "a_position"), c.colorLocation = r.getAttribLocation(l, "a_color"), p = c }(); var f = p, A = f.canvas, g = f.gl; A.width = t, A.height = r, g.viewport(0, 0, g.drawingBufferWidth, g.drawingBufferHeight), g.uniform2f(f.resolutionLocation, t, r); var m, v, b, S = 0; for (m = 0, v = c.length; m < v; m++) switch (c[m].type) { case "lattice": S += ((b = c[m].coords.length / c[m].verticesPerRow | 0) - 1) * (c[m].verticesPerRow - 1) * 6; break; case "triangles": S += c[m].coords.length } var y = new Float32Array(2 * S), x = new Uint8Array(3 * S), P = h.coords, k = h.colors, C = 0, F = 0; for (m = 0, v = c.length; m < v; m++) { var D = c[m], T = D.coords, w = D.colors; switch (D.type) { case "lattice": var L = D.verticesPerRow; b = T.length / L | 0; for (var R = 1; R < b; R++) for (var E = R * L + 1, I = 1; I < L; I++, E++) y[C] = P[T[E - L - 1]], y[C + 1] = P[T[E - L - 1] + 1], y[C + 2] = P[T[E - L]], y[C + 3] = P[T[E - L] + 1], y[C + 4] = P[T[E - 1]], y[C + 5] = P[T[E - 1] + 1], x[F] = k[w[E - L - 1]], x[F + 1] = k[w[E - L - 1] + 1], x[F + 2] = k[w[E - L - 1] + 2], x[F + 3] = k[w[E - L]], x[F + 4] = k[w[E - L] + 1], x[F + 5] = k[w[E - L] + 2], x[F + 6] = k[w[E - 1]], x[F + 7] = k[w[E - 1] + 1], x[F + 8] = k[w[E - 1] + 2], y[C + 6] = y[C + 2], y[C + 7] = y[C + 3], y[C + 8] = y[C + 4], y[C + 9] = y[C + 5], y[C + 10] = P[T[E]], y[C + 11] = P[T[E] + 1], x[F + 9] = x[F + 3], x[F + 10] = x[F + 4], x[F + 11] = x[F + 5], x[F + 12] = x[F + 6], x[F + 13] = x[F + 7], x[F + 14] = x[F + 8], x[F + 15] = k[w[E]], x[F + 16] = k[w[E] + 1], x[F + 17] = k[w[E] + 2], C += 12, F += 18; break; case "triangles": for (var _ = 0, M = T.length; _ < M; _++) y[C] = P[T[_]], y[C + 1] = P[T[_] + 1], x[F] = k[w[_]], x[F + 1] = k[w[_] + 1], x[F + 2] = k[w[_] + 2], C += 2, F += 3 } } l ? g.clearColor(l[0] / 255, l[1] / 255, l[2] / 255, 1) : g.clearColor(0, 0, 0, 0), g.clear(g.COLOR_BUFFER_BIT); var N = g.createBuffer(); g.bindBuffer(g.ARRAY_BUFFER, N), g.bufferData(g.ARRAY_BUFFER, y, g.STATIC_DRAW), g.enableVertexAttribArray(f.positionLocation), g.vertexAttribPointer(f.positionLocation, 2, g.FLOAT, !1, 0, 0); var O = g.createBuffer(); return g.bindBuffer(g.ARRAY_BUFFER, O), g.bufferData(g.ARRAY_BUFFER, x, g.STATIC_DRAW), g.enableVertexAttribArray(f.colorLocation), g.vertexAttribPointer(f.colorLocation, 3, g.UNSIGNED_BYTE, !1, 0, 0), g.uniform2f(f.scaleLocation, h.scaleX, h.scaleY), g.uniform2f(f.offsetLocation, h.offsetX, h.offsetY), g.drawArrays(g.TRIANGLES, 0, S), g.flush(), g.deleteBuffer(N), g.deleteBuffer(O), A }, clear: function () { h && h.canvas && (h.canvas.width = 0, h.canvas.height = 0), p && p.canvas && (p.canvas.width = 0, p.canvas.height = 0), h = null, p = null } } }(), tt = { RadialAxial: { fromIR: function (t) { var e = t[1], n = t[2], i = t[3], r = t[4], a = t[5], s = t[6]; return { type: "Pattern", getPattern: function (t) { var o; "axial" === e ? o = t.createLinearGradient(i[0], i[1], r[0], r[1]) : "radial" === e && (o = t.createRadialGradient(i[0], i[1], a, r[0], r[1], s)); for (var l = 0, c = n.length; l < c; ++l) { var h = n[l]; o.addColorStop(h[0], h[1]) } return o } } } } }, et = function () { function t(t, e, n, i, r, a, s, o) { var l, c = e.coords, h = e.colors, u = t.data, d = 4 * t.width; c[n + 1] > c[i + 1] && (l = n, n = i, i = l, l = a, a = s, s = l), c[i + 1] > c[r + 1] && (l = i, i = r, r = l, l = s, s = o, o = l), c[n + 1] > c[i + 1] && (l = n, n = i, i = l, l = a, a = s, s = l); var p = (c[n] + e.offsetX) * e.scaleX, f = (c[n + 1] + e.offsetY) * e.scaleY, A = (c[i] + e.offsetX) * e.scaleX, g = (c[i + 1] + e.offsetY) * e.scaleY, m = (c[r] + e.offsetX) * e.scaleX, v = (c[r + 1] + e.offsetY) * e.scaleY; if (!(f >= v)) for (var b, S, y, x, P, k, C, F, D, T = h[a], w = h[a + 1], L = h[a + 2], R = h[s], E = h[s + 1], I = h[s + 2], _ = h[o], M = h[o + 1], N = h[o + 2], O = Math.round(f), j = Math.round(v), J = O; J <= j; J++) { J < g ? (b = p - (p - A) * (D = J < f ? 0 : f === g ? 1 : (f - J) / (f - g)), S = T - (T - R) * D, y = w - (w - E) * D, x = L - (L - I) * D) : (b = A - (A - m) * (D = J > v ? 1 : g === v ? 0 : (g - J) / (g - v)), S = R - (R - _) * D, y = E - (E - M) * D, x = I - (I - N) * D), P = p - (p - m) * (D = J < f ? 0 : J > v ? 1 : (f - J) / (f - v)), k = T - (T - _) * D, C = w - (w - M) * D, F = L - (L - N) * D; for (var B = Math.round(Math.min(b, P)), W = Math.round(Math.max(b, P)), U = d * J + 4 * B, G = B; G <= W; G++) D = (D = (b - G) / (b - P)) < 0 ? 0 : D > 1 ? 1 : D, u[U++] = S - (S - k) * D | 0, u[U++] = y - (y - C) * D | 0, u[U++] = x - (x - F) * D | 0, u[U++] = 255 } } function e(e, n, i) { var r, a, s = n.coords, o = n.colors; switch (n.type) { case "lattice": var l = n.verticesPerRow, c = Math.floor(s.length / l) - 1, h = l - 1; for (r = 0; r < c; r++) for (var d = r * l, p = 0; p < h; p++, d++) t(e, i, s[d], s[d + 1], s[d + l], o[d], o[d + 1], o[d + l]), t(e, i, s[d + l + 1], s[d + 1], s[d + l], o[d + l + 1], o[d + 1], o[d + l]); break; case "triangles": for (r = 0, a = s.length; r < a; r += 3) t(e, i, s[r], s[r + 1], s[r + 2], o[r], o[r + 1], o[r + 2]); break; default: u("illigal figure") } } return function (t, n, i, r, a, s) { var o, l, c, h, u = Math.floor(t[0]), d = Math.floor(t[1]), p = Math.ceil(t[2]) - u, f = Math.ceil(t[3]) - d, A = Math.min(Math.ceil(Math.abs(p * n[0] * 1.1)), 3e3), g = Math.min(Math.ceil(Math.abs(f * n[1] * 1.1)), 3e3), m = p / A, v = f / g, b = { coords: i, colors: r, offsetX: -u, offsetY: -d, scaleX: 1 / m, scaleY: 1 / v }; if ($.isEnabled) o = $.drawFigures(A, g, s, a, b), (l = q.getCanvas("mesh", A, g, !1)).context.drawImage(o, 0, 0), o = l.canvas; else { var S = (l = q.getCanvas("mesh", A, g, !1)).context, y = S.createImageData(A, g); if (s) { var x = y.data; for (c = 0, h = x.length; c < h; c += 4) x[c] = s[0], x[c + 1] = s[1], x[c + 2] = s[2], x[c + 3] = 255 } for (c = 0; c < a.length; c++) e(y, a[c], b); S.putImageData(y, 0, 0), o = l.canvas } return { canvas: o, offsetX: u, offsetY: d, scaleX: m, scaleY: v } } }(); function nt(t) { var e = tt[t[0]]; return e || u("Unknown IR type: " + t[0]), e.fromIR(t) } tt.Mesh = { fromIR: function (t) { var e = t[2], n = t[3], i = t[4], r = t[5], a = t[6], s = t[8]; return { type: "Pattern", getPattern: function (t, o, l) { var c; if (l) c = L.singularValueDecompose2dScale(t.mozCurrentTransform); else if (c = L.singularValueDecompose2dScale(o.baseTransform), a) { var h = L.singularValueDecompose2dScale(a); c = [c[0] * h[0], c[1] * h[1]] } var u = et(r, c, e, n, i, l ? null : s); return l || (t.setTransform.apply(t, o.baseTransform), a && t.transform.apply(t, a)), t.translate(u.offsetX, u.offsetY), t.scale(u.scaleX, u.scaleY), t.createPattern(u.canvas, "no-repeat") } } } }, tt.Dummy = { fromIR: function () { return { type: "Pattern", getPattern: function () { return "hotpink" } } } }; var it = function () { var t = 1, e = 2; function n(t, e, n, i, r, a) { this.operatorList = t[2], this.matrix = t[3] || [1, 0, 0, 1, 0, 0], this.bbox = t[4], this.xstep = t[5], this.ystep = t[6], this.paintType = t[7], this.tilingType = t[8], this.color = e, this.objs = i, this.commonObjs = r, this.baseTransform = a, this.type = "Pattern", this.ctx = n } return n.prototype = { createPatternCanvas: function (t) { var e = this.operatorList, n = this.bbox, i = this.xstep, r = this.ystep, a = this.paintType, s = this.tilingType, o = this.color, c = this.objs, h = this.commonObjs; l("TilingType: " + s); var u = n[0], d = n[1], p = n[2], f = n[3], A = [u, d], g = [u + i, d + r], m = g[0] - A[0], v = g[1] - A[1], b = L.singularValueDecompose2dScale(this.matrix), S = L.singularValueDecompose2dScale(this.baseTransform), y = [b[0] * S[0], b[1] * S[1]]; m = Math.min(Math.ceil(Math.abs(m * y[0])), 3e3), v = Math.min(Math.ceil(Math.abs(v * y[1])), 3e3); var x = q.getCanvas("pattern", m, v, !0), P = x.context, k = new Z(P, h, c); k.groupLevel = t.groupLevel, this.setFillAndStrokeStyleToContext(P, a, o), this.setScale(m, v, i, r), this.transformToScale(k); var C = [1, 0, 0, 1, -A[0], -A[1]]; return k.transform.apply(k, C), this.clipBbox(k, n, u, d, p, f), k.executeOperatorList(e), x.canvas }, setScale: function (t, e, n, i) { this.scale = [t / n, e / i] }, transformToScale: function (t) { var e = this.scale, n = [e[0], 0, 0, e[1], 0, 0]; t.transform.apply(t, n) }, scaleToContext: function () { var t = this.scale; this.ctx.scale(1 / t[0], 1 / t[1]) }, clipBbox: function (t, e, n, i, r, a) { if (e && E(e) && 4 === e.length) { var s = r - n, o = a - i; t.ctx.rect(n, i, s, o), t.clip(), t.endPath() } }, setFillAndStrokeStyleToContext: function (n, i, r) { switch (i) { case t: var a = this.ctx; n.fillStyle = a.fillStyle, n.strokeStyle = a.strokeStyle; break; case e: var s = L.makeCssRgb(r[0], r[1], r[2]); n.fillStyle = s, n.strokeStyle = s; break; default: u("Unsupported paint type: " + i) } }, getPattern: function (t, e) { var n = this.createPatternCanvas(e); return (t = this.ctx).setTransform.apply(t, this.baseTransform), t.transform.apply(t, this.matrix), this.scaleToContext(), t.createPattern(n, "repeat") } }, n }(); PDFJS.disableFontFace = !1; var rt = { insertRule: function (t) { var e = document.getElementById("PDFJS_FONT_STYLE_TAG"); e || ((e = document.createElement("style")).id = "PDFJS_FONT_STYLE_TAG", document.documentElement.getElementsByTagName("head")[0].appendChild(e)); var n = e.sheet; n.insertRule(t, n.cssRules.length) }, clear: function () { var t = document.getElementById("PDFJS_FONT_STYLE_TAG"); t && t.parentNode.removeChild(t), this.nativeFontFaces.forEach(function (t) { document.fonts.delete(t) }), this.nativeFontFaces.length = 0 }, get loadTestFont() { return m(this, "loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==")) }, get isEvalSupported() { var t = !1; if (PDFJS.isEvalSupported) try { new Function(""), t = !0 } catch (t) { } return m(this, "isEvalSupported", t) }, loadTestFontId: 0, loadingContext: { requests: [], nextRequestId: 0 }, isSyncFontLoadingSupported: function () { if (e) return !1; var t = window.navigator.userAgent, n = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(t); return !!(n && n[1] >= 14) || "node" === t }(), nativeFontFaces: [], isFontLoadingAPISupported: !e && "undefined" != typeof document && !!document.fonts, addNativeFontFace: function (t) { this.nativeFontFaces.push(t), document.fonts.add(t) }, bind: function (t, n) { d(!e, "bind() shall be called from main thread"); for (var i = [], r = [], a = [], s = function (t) { return t.loaded.catch(function (e) { c('Failed to load font "' + t.family + '": ' + e) }) }, o = 0, l = t.length; o < l; o++) { var h = t[o]; if (!h.attached && !1 !== h.loading) if (h.attached = !0, this.isFontLoadingAPISupported) { var u = h.createNativeFontFace(); u && a.push(s(u)) } else { var p = h.bindDOM(); p && (i.push(p), r.push(h)) } } var f = rt.queueLoadingCallback(n); this.isFontLoadingAPISupported ? Promise.all(a).then(function () { f.complete() }) : i.length > 0 && !this.isSyncFontLoadingSupported ? rt.prepareFontLoadEvent(i, r, f) : f.complete() }, queueLoadingCallback: function (t) { var e = rt.loadingContext, n = { id: "pdfjs-font-loading-" + e.nextRequestId++, complete: function () { for (d(!n.end, "completeRequest() cannot be called twice"), n.end = Date.now() ; e.requests.length > 0 && e.requests[0].end;) { var t = e.requests.shift(); setTimeout(t.callback, 0) } }, callback: t, started: Date.now() }; return e.requests.push(n), n }, prepareFontLoadEvent: function (t, e, n) { function i(t, e) { return t.charCodeAt(e) << 24 | t.charCodeAt(e + 1) << 16 | t.charCodeAt(e + 2) << 8 | 255 & t.charCodeAt(e + 3) } function r(t, e, n, i) { return t.substr(0, e) + i + t.substr(e + n) } var a, s, o = document.createElement("canvas"); o.width = 1, o.height = 1; var l = o.getContext("2d"), h = 0; var u, d = "lt" + Date.now() + this.loadTestFontId++, p = this.loadTestFont, f = i(p = r(p, 976, d.length, d), 16); for (a = 0, s = d.length - 3; a < s; a += 4) f = f - 1482184792 + i(d, a) | 0; a < d.length && (f = f - 1482184792 + i(d + "XXX", a) | 0), p = r(p, 16, 4, (u = f, String.fromCharCode(u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u))); var A = '@font-face { font-family:"' + d + '";src:' + ("url(data:font/opentype;base64," + btoa(p) + ");") + "}"; rt.insertRule(A); var g = []; for (a = 0, s = e.length; a < s; a++) g.push(e[a].loadedName); g.push(d); var m = document.createElement("div"); for (m.setAttribute("style", "visibility: hidden;width: 10px; height: 10px;position: absolute; top: 0px; left: 0px;"), a = 0, s = g.length; a < s; ++a) { var v = document.createElement("span"); v.textContent = "Hi", v.style.fontFamily = g[a], m.appendChild(v) } document.body.appendChild(m), function t(e, n) { if (++h > 30) return c("Load test font never loaded."), void n(); l.font = "30px " + e, l.fillText(".", 0, 20), l.getImageData(0, 0, 1, 1).data[3] > 0 ? n() : setTimeout(t.bind(null, e, n)) }(d, function () { document.body.removeChild(m), n.complete() }) } }, at = function () { function e(t, e, n) { if (this.compiledGlyphs = {}, 1 !== arguments.length); else { var i = arguments[0]; for (var r in i) this[r] = i[r] } } return e.prototype = { createNativeFontFace: function () { if (!this.data) return null; if (PDFJS.disableFontFace) return this.disableFontFace = !0, null; var e = new FontFace(this.loadedName, this.data, {}); return rt.addNativeFontFace(e), PDFJS.pdfBug && "FontInspector" in t && t.FontInspector.enabled && t.FontInspector.fontAdded(this), e }, bindDOM: function () { if (!this.data) return null; if (PDFJS.disableFontFace) return this.disableFontFace = !0, null; var e = function (t) { d(null !== t && "object" == typeof t && void 0 !== t.length, "Invalid argument for bytesToString"); var e = t.length; if (e < 8192) return String.fromCharCode.apply(null, t); for (var n = [], i = 0; i < e; i += 8192) { var r = Math.min(i + 8192, e), a = t.subarray(i, r); n.push(String.fromCharCode.apply(null, a)) } return n.join("") }(new Uint8Array(this.data)), n = this.loadedName, i = "url(data:" + this.mimetype + ";base64," + window.btoa(e) + ");", r = '@font-face { font-family:"' + n + '";src:' + i + "}"; return rt.insertRule(r), PDFJS.pdfBug && "FontInspector" in t && t.FontInspector.enabled && t.FontInspector.fontAdded(this, i), r }, getPathGenerator: function (t, e) { if (!(e in this.compiledGlyphs)) { var n, i, r, a = t.get(this.loadedName + "_path_" + e); if (rt.isEvalSupported) { var s, o = ""; for (i = 0, r = a.length; i < r; i++) s = void 0 !== (n = a[i]).args ? n.args.join(",") : "", o += "c." + n.cmd + "(" + s + ");\n"; this.compiledGlyphs[e] = new Function("c", "size", o) } else this.compiledGlyphs[e] = function (t, e) { for (i = 0, r = a.length; i < r; i++) "scale" === (n = a[i]).cmd && (n.args = [e, -e]), t[n.cmd].apply(t, n.args) } } return this.compiledGlyphs[e] } }, e }(), st = 10, ot = function () { function t(t) { var e = document.createElement("section"), n = e.style, i = t.rect[2] - t.rect[0], r = t.rect[3] - t.rect[1]; if (t.borderStyle.width > 0) { e.style.borderWidth = t.borderStyle.width + "px", t.borderStyle.style !== s.UNDERLINE && (i -= 2 * t.borderStyle.width, r -= 2 * t.borderStyle.width); var a = t.borderStyle.horizontalCornerRadius, o = t.borderStyle.verticalCornerRadius; if (a > 0 || o > 0) { var l = a + "px / " + o + "px"; CustomStyle.setProp("borderRadius", e, l) } switch (t.borderStyle.style) { case s.SOLID: e.style.borderStyle = "solid"; break; case s.DASHED: e.style.borderStyle = "dashed"; break; case s.BEVELED: c("Unimplemented border style: beveled"); break; case s.INSET: c("Unimplemented border style: inset"); break; case s.UNDERLINE: e.style.borderBottomStyle = "solid" } t.color ? e.style.borderColor = L.makeCssRgb(0 | t.color[0], 0 | t.color[1], 0 | t.color[2]) : e.style.borderWidth = 0 } return n.width = i + "px", n.height = r + "px", e } function e(e) { var n = e.rect; n[3] - n[1] < st && (n[3] = n[1] + st), n[2] - n[0] < st && (n[2] = n[0] + (n[3] - n[1])); var i = t(e); i.className = "annotText"; var r = document.createElement("img"); r.style.height = i.style.height, r.style.width = i.style.width; var a = e.name; r.src = PDFJS.imageResourcesPath + "annotation-" + a.toLowerCase() + ".svg", r.alt = "[{{type}} Annotation]", r.dataset.l10nId = "text_annotation_type", r.dataset.l10nArgs = JSON.stringify({ type: a }); var s = document.createElement("div"); s.className = "annotTextContentWrapper", s.style.left = Math.floor(n[2] - n[0] + 5) + "px", s.style.top = "-10px"; var o, l, c = document.createElement("div"); if (c.className = "annotTextContent", c.setAttribute("hidden", !0), e.hasBgColor && e.color) { var h = e.color, u = .7 * (255 - h[0]) + h[0], d = .7 * (255 - h[1]) + h[1], p = .7 * (255 - h[2]) + h[2]; c.style.backgroundColor = L.makeCssRgb(0 | u, 0 | d, 0 | p) } var f = document.createElement("h1"), A = document.createElement("p"); if (f.textContent = e.title, e.content || e.title) { var g = document.createElement("span"), m = e.content.split(/(?:\r\n?|\n)/); for (o = 0, l = m.length; o < l; ++o) { var v = m[o]; g.appendChild(document.createTextNode(v)), o < l - 1 && g.appendChild(document.createElement("br")) } A.appendChild(g); var b = !1, S = function (t) { t && (b = !0), c.hasAttribute("hidden") && (i.style.zIndex += 1, c.removeAttribute("hidden")) }, y = function (t) { t && (b = !1), c.hasAttribute("hidden") || b || (i.style.zIndex -= 1, c.setAttribute("hidden", !0)) }; r.addEventListener("click", function () { b ? y(!0) : S(!0) }, !1), r.addEventListener("mouseover", function () { S() }, !1), r.addEventListener("mouseout", function () { y() }, !1), c.addEventListener("click", function () { y(!0) }, !1) } else c.setAttribute("hidden", !0); return c.appendChild(f), c.appendChild(A), s.appendChild(c), i.appendChild(r), i.appendChild(s), i } return { getHtmlElement: function (n, i) { switch (n.annotationType) { case a.WIDGET: return function (t, e) { var n = document.createElement("div"), i = t.rect[2] - t.rect[0], r = t.rect[3] - t.rect[1]; n.style.width = i + "px", n.style.height = r + "px", n.style.display = "table"; var a = document.createElement("div"); a.textContent = t.fieldValue; var s = t.textAlignment; return a.style.textAlign = ["left", "center", "right"][s], a.style.verticalAlign = "middle", a.style.display = "table-cell", function (t, e, n) { var i = t.style; if (i.fontSize = e.fontSize + "px", i.direction = e.fontDirection < 0 ? "rtl" : "ltr", n) { i.fontWeight = n.black ? n.bold ? "bolder" : "bold" : n.bold ? "bold" : "normal", i.fontStyle = n.italic ? "italic" : "normal"; var r = n.loadedName, a = r ? '"' + r + '", ' : "", s = n.fallbackName || "Helvetica, sans-serif"; i.fontFamily = a + s } }(a, t, t.fontRefName ? e.getData(t.fontRefName) : null), n.appendChild(a), n }(n, i); case a.TEXT: return e(n); case a.LINK: return function (e) { var n = t(e); n.className = "annotLink"; var i = document.createElement("a"); return i.href = i.title = e.url || "", e.url && S() && (i.target = b[PDFJS.externalLinkTarget]), n.appendChild(i), n }(n); default: throw new Error("Unsupported annotationType: " + n.annotationType) } } } }(); PDFJS.AnnotationUtils = ot; var lt = { fontStyle: "normal", fontWeight: "normal", fillColor: "#000000" }, ct = function () { for (var t = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), e = 12, n = new Int32Array(256), i = 0; i < 256; i++) { for (var a = i, s = 0; s < 8; s++) a = 1 & a ? 3988292384 ^ a >> 1 & 2147483647 : a >> 1 & 2147483647; n[i] = a } function o(t, e, i, r) { var a = r, s = e.length; i[a] = s >> 24 & 255, i[a + 1] = s >> 16 & 255, i[a + 2] = s >> 8 & 255, i[a + 3] = 255 & s, i[a += 4] = 255 & t.charCodeAt(0), i[a + 1] = 255 & t.charCodeAt(1), i[a + 2] = 255 & t.charCodeAt(2), i[a + 3] = 255 & t.charCodeAt(3), a += 4, i.set(e, a); var o = function (t, e, i) { for (var r = -1, a = e; a < i; a++) { var s = 255 & (r ^ t[a]); r = r >>> 8 ^ n[s] } return -1 ^ r }(i, r + 4, a += e.length); i[a] = o >> 24 & 255, i[a + 1] = o >> 16 & 255, i[a + 2] = o >> 8 & 255, i[a + 3] = 255 & o } return function (n) { return function (n, i) { var a, s, l, c = n.width, h = n.height, u = n.data; switch (i) { case r.GRAYSCALE_1BPP: s = 0, a = 1, l = c + 7 >> 3; break; case r.RGB_24BPP: s = 2, a = 8, l = 3 * c; break; case r.RGBA_32BPP: s = 6, a = 8, l = 4 * c; break; default: throw new Error("invalid format") } var d, p, f = new Uint8Array((1 + l) * h), A = 0, g = 0; for (d = 0; d < h; ++d) f[A++] = 0, f.set(u.subarray(g, g + l), A), g += l, A += l; if (i === r.GRAYSCALE_1BPP) for (A = 0, d = 0; d < h; d++) for (A++, p = 0; p < l; p++) f[A++] ^= 255; var m = new Uint8Array([c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h, a, s, 0, 0, 0]), v = f.length, b = Math.ceil(v / 65535), S = new Uint8Array(2 + v + 5 * b + 4), y = 0; S[y++] = 120, S[y++] = 156; for (var x = 0; v > 65535;) S[y++] = 0, S[y++] = 255, S[y++] = 255, S[y++] = 0, S[y++] = 0, S.set(f.subarray(x, x + 65535), y), y += 65535, x += 65535, v -= 65535; S[y++] = 1, S[y++] = 255 & v, S[y++] = v >> 8 & 255, S[y++] = 255 & ~v, S[y++] = (65535 & ~v) >> 8 & 255, S.set(f.subarray(x), y), y += f.length - x; var P = function (t, e, n) { for (var i = 1, r = 0, a = e; a < n; ++a) r = (r + (i = (i + (255 & t[a])) % 65521)) % 65521; return r << 16 | i }(f, 0, f.length); S[y++] = P >> 24 & 255, S[y++] = P >> 16 & 255, S[y++] = P >> 8 & 255, S[y++] = 255 & P; var k = t.length + 3 * e + m.length + S.length, C = new Uint8Array(k), F = 0; return C.set(t, F), o("IHDR", m, C, F += t.length), o("IDATA", S, C, F += e + m.length), F += e + S.length, o("IEND", new Uint8Array(0), C, F), PDFJS.createObjectURL(C, "image/png") }(n, void 0 === n.kind ? r.GRAYSCALE_1BPP : n.kind) } }(), ht = function () { function t() { this.fontSizeScale = 1, this.fontWeight = lt.fontWeight, this.fontSize = 0, this.textMatrix = w, this.fontMatrix = n, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = lt.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.clipId = "", this.pendingClip = !1, this.maskId = "" } return t.prototype = { clone: function () { return Object.create(this) }, setCurrentPoint: function (t, e) { this.x = t, this.y = e } }, t }(), ut = function () { function t(t) { if (t === (0 | t)) return t.toString(); var e = t.toFixed(10), n = e.length - 1; if ("0" !== e[n]) return e; do { n-- } while ("0" === e[n]); return e.substr(0, "." === e[n] ? n : n + 1) } function e(e) { if (0 === e[4] && 0 === e[5]) { if (0 === e[1] && 0 === e[2]) return 1 === e[0] && 1 === e[3] ? "" : "scale(" + t(e[0]) + " " + t(e[3]) + ")"; if (e[0] === e[3] && e[1] === -e[2]) return "rotate(" + t(180 * Math.acos(e[0]) / Math.PI) + ")" } else if (1 === e[0] && 0 === e[1] && 0 === e[2] && 1 === e[3]) return "translate(" + t(e[4]) + " " + t(e[5]) + ")"; return "matrix(" + t(e[0]) + " " + t(e[1]) + " " + t(e[2]) + " " + t(e[3]) + " " + t(e[4]) + " " + t(e[5]) + ")" } function i(t, e) { this.current = new ht, this.transformMatrix = w, this.transformStack = [], this.extraStack = [], this.commonObjs = t, this.objs = e, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = {}, this.cssStyle = null } var r = "http://www.w3.org/2000/svg", a = "http://www.w3.org/1999/xlink", s = ["butt", "round", "square"], l = ["miter", "round", "bevel"], h = 0, u = 0; return i.prototype = { save: function () { this.transformStack.push(this.transformMatrix); var t = this.current; this.extraStack.push(t), this.current = t.clone() }, restore: function () { this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.tgrp = document.createElementNS(r, "svg:g"), this.tgrp.setAttributeNS(null, "transform", e(this.transformMatrix)), this.pgrp.appendChild(this.tgrp) }, group: function (t) { this.save(), this.executeOpTree(t), this.restore() }, loadDependencies: function (t) { for (var e = t.fnArray, n = e.length, i = t.argsArray, r = this, a = 0; a < n; a++) if (o.dependency === e[a]) for (var s = i[a], l = 0, c = s.length; l < c; l++) { var h, u = s[l]; h = "g_" === u.substring(0, 2) ? new Promise(function (t) { r.commonObjs.get(u, t) }) : new Promise(function (t) { r.objs.get(u, t) }), this.current.dependencies.push(h) } return Promise.all(this.current.dependencies) }, transform: function (t, n, i, a, s, o) { var l = [t, n, i, a, s, o]; this.transformMatrix = PDFJS.Util.transform(this.transformMatrix, l), this.tgrp = document.createElementNS(r, "svg:g"), this.tgrp.setAttributeNS(null, "transform", e(this.transformMatrix)) }, getSVG: function (t, n) { var i, a, s; return this.svg = (i = n.width, a = n.height, (s = document.createElementNS("http://www.w3.org/2000/svg", "svg:svg")).setAttributeNS(null, "version", "1.1"), s.setAttributeNS(null, "width", i + "px"), s.setAttributeNS(null, "height", a + "px"), s.setAttributeNS(null, "viewBox", "0 0 " + i + " " + a), s), this.viewport = n, this.loadDependencies(t).then(function () { this.transformMatrix = w, this.pgrp = document.createElementNS(r, "svg:g"), this.pgrp.setAttributeNS(null, "transform", e(n.transform)), this.tgrp = document.createElementNS(r, "svg:g"), this.tgrp.setAttributeNS(null, "transform", e(this.transformMatrix)), this.defs = document.createElementNS(r, "svg:defs"), this.pgrp.appendChild(this.defs), this.pgrp.appendChild(this.tgrp), this.svg.appendChild(this.pgrp); var i = this.convertOpList(t); return this.executeOpTree(i), this.svg }.bind(this)) }, convertOpList: function (t) { var e = t.argsArray, n = t.fnArray, i = n.length, r = [], a = []; for (var s in o) r[o[s]] = s; for (var l = 0; l < i; l++) { var c = n[l]; a.push({ fnId: c, fn: r[c], args: e[l] }) } return function (t) { for (var e = [], n = [], i = t.length, r = 0; r < i; r++) "save" !== t[r].fn ? "restore" === t[r].fn ? e = n.pop() : e.push(t[r]) : (e.push({ fnId: 92, fn: "group", items: [] }), n.push(e), e = e[e.length - 1].items); return e }(a) }, executeOpTree: function (t) { for (var e = t.length, n = 0; n < e; n++) { var i = t[n].fn, r = t[n].fnId, a = t[n].args; switch (0 | r) { case o.beginText: this.beginText(); break; case o.setLeading: this.setLeading(a); break; case o.setLeadingMoveText: this.setLeadingMoveText(a[0], a[1]); break; case o.setFont: this.setFont(a); break; case o.showText: case o.showSpacedText: this.showText(a[0]); break; case o.endText: this.endText(); break; case o.moveText: this.moveText(a[0], a[1]); break; case o.setCharSpacing: this.setCharSpacing(a[0]); break; case o.setWordSpacing: this.setWordSpacing(a[0]); break; case o.setHScale: this.setHScale(a[0]); break; case o.setTextMatrix: this.setTextMatrix(a[0], a[1], a[2], a[3], a[4], a[5]); break; case o.setLineWidth: this.setLineWidth(a[0]); break; case o.setLineJoin: this.setLineJoin(a[0]); break; case o.setLineCap: this.setLineCap(a[0]); break; case o.setMiterLimit: this.setMiterLimit(a[0]); break; case o.setFillRGBColor: this.setFillRGBColor(a[0], a[1], a[2]); break; case o.setStrokeRGBColor: this.setStrokeRGBColor(a[0], a[1], a[2]); break; case o.setDash: this.setDash(a[0], a[1]); break; case o.setGState: this.setGState(a[0]); break; case o.fill: this.fill(); break; case o.eoFill: this.eoFill(); break; case o.stroke: this.stroke(); break; case o.fillStroke: this.fillStroke(); break; case o.eoFillStroke: this.eoFillStroke(); break; case o.clip: this.clip("nonzero"); break; case o.eoClip: this.clip("evenodd"); break; case o.paintSolidColorImageMask: this.paintSolidColorImageMask(); break; case o.paintJpegXObject: this.paintJpegXObject(a[0], a[1], a[2]); break; case o.paintImageXObject: this.paintImageXObject(a[0]); break; case o.paintInlineImageXObject: this.paintInlineImageXObject(a[0]); break; case o.paintImageMaskXObject: this.paintImageMaskXObject(a[0]); break; case o.paintFormXObjectBegin: this.paintFormXObjectBegin(a[0], a[1]); break; case o.paintFormXObjectEnd: this.paintFormXObjectEnd(); break; case o.closePath: this.closePath(); break; case o.closeStroke: this.closeStroke(); break; case o.closeFillStroke: this.closeFillStroke(); break; case o.nextLine: this.nextLine(); break; case o.transform: this.transform(a[0], a[1], a[2], a[3], a[4], a[5]); break; case o.constructPath: this.constructPath(a[0], a[1]); break; case o.endPath: this.endPath(); break; case 92: this.group(t[n].items); break; default: c("Unimplemented method " + i) } } }, setWordSpacing: function (t) { this.current.wordSpacing = t }, setCharSpacing: function (t) { this.current.charSpacing = t }, nextLine: function () { this.moveText(0, this.current.leading) }, setTextMatrix: function (e, n, i, a, s, o) { var l = this.current; this.current.textMatrix = this.current.lineMatrix = [e, n, i, a, s, o], this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0, l.xcoords = [], l.tspan = document.createElementNS(r, "svg:tspan"), l.tspan.setAttributeNS(null, "font-family", l.fontFamily), l.tspan.setAttributeNS(null, "font-size", t(l.fontSize) + "px"), l.tspan.setAttributeNS(null, "y", t(-l.y)), l.txtElement = document.createElementNS(r, "svg:text"), l.txtElement.appendChild(l.tspan) }, beginText: function () { this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0, this.current.textMatrix = w, this.current.lineMatrix = w, this.current.tspan = document.createElementNS(r, "svg:tspan"), this.current.txtElement = document.createElementNS(r, "svg:text"), this.current.txtgrp = document.createElementNS(r, "svg:g"), this.current.xcoords = [] }, moveText: function (e, n) { var i = this.current; this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += n, i.xcoords = [], i.tspan = document.createElementNS(r, "svg:tspan"), i.tspan.setAttributeNS(null, "font-family", i.fontFamily), i.tspan.setAttributeNS(null, "font-size", t(i.fontSize) + "px"), i.tspan.setAttributeNS(null, "y", t(-i.y)) }, showText: function (n) { var i = this.current, r = i.font, a = i.fontSize; if (0 !== a) { var s, o = i.charSpacing, l = i.wordSpacing, c = i.fontDirection, h = i.textHScale * c, u = n.length, d = r.vertical, p = a * i.fontMatrix[0], f = 0; for (s = 0; s < u; ++s) { var A = n[s]; if (null !== A) if (R(A)) f += -A * a * .001; else { i.xcoords.push(i.x + f * h); var g = A.width, m = A.fontChar; f += g * p + o * c, i.tspan.textContent += m } else f += c * l } d ? i.y -= f * h : i.x += f * h, i.tspan.setAttributeNS(null, "x", i.xcoords.map(t).join(" ")), i.tspan.setAttributeNS(null, "y", t(-i.y)), i.tspan.setAttributeNS(null, "font-family", i.fontFamily), i.tspan.setAttributeNS(null, "font-size", t(i.fontSize) + "px"), i.fontStyle !== lt.fontStyle && i.tspan.setAttributeNS(null, "font-style", i.fontStyle), i.fontWeight !== lt.fontWeight && i.tspan.setAttributeNS(null, "font-weight", i.fontWeight), i.fillColor !== lt.fillColor && i.tspan.setAttributeNS(null, "fill", i.fillColor), i.txtElement.setAttributeNS(null, "transform", e(i.textMatrix) + " scale(1, -1)"), i.txtElement.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), i.txtElement.appendChild(i.tspan), i.txtgrp.appendChild(i.txtElement), this.tgrp.appendChild(i.txtElement) } }, setLeadingMoveText: function (t, e) { this.setLeading(-e), this.moveText(t, e) }, addFontStyle: function (t) { this.cssStyle || (this.cssStyle = document.createElementNS(r, "svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.appendChild(this.cssStyle)); var e = PDFJS.createObjectURL(t.data, t.mimetype); this.cssStyle.textContent += '@font-face { font-family: "' + t.loadedName + '"; src: url(' + e + "); }\n" }, setFont: function (e) { var i = this.current, a = this.commonObjs.get(e[0]), s = e[1]; this.current.font = a, this.embedFonts && a.data && !this.embeddedFonts[a.loadedName] && (this.addFontStyle(a), this.embeddedFonts[a.loadedName] = a), i.fontMatrix = a.fontMatrix ? a.fontMatrix : n; var o = a.black ? a.bold ? "bolder" : "bold" : a.bold ? "bold" : "normal", l = a.italic ? "italic" : "normal"; s < 0 ? (s = -s, i.fontDirection = -1) : i.fontDirection = 1, i.fontSize = s, i.fontFamily = a.loadedName, i.fontWeight = o, i.fontStyle = l, i.tspan = document.createElementNS(r, "svg:tspan"), i.tspan.setAttributeNS(null, "y", t(-i.y)), i.xcoords = [] }, endText: function () { this.current.pendingClip ? (this.cgrp.appendChild(this.tgrp), this.pgrp.appendChild(this.cgrp)) : this.pgrp.appendChild(this.tgrp), this.tgrp = document.createElementNS(r, "svg:g"), this.tgrp.setAttributeNS(null, "transform", e(this.transformMatrix)) }, setLineWidth: function (t) { this.current.lineWidth = t }, setLineCap: function (t) { this.current.lineCap = s[t] }, setLineJoin: function (t) { this.current.lineJoin = l[t] }, setMiterLimit: function (t) { this.current.miterLimit = t }, setStrokeRGBColor: function (t, e, n) { var i = L.makeCssRgb(t, e, n); this.current.strokeColor = i }, setFillRGBColor: function (t, e, n) { var i = L.makeCssRgb(t, e, n); this.current.fillColor = i, this.current.tspan = document.createElementNS(r, "svg:tspan"), this.current.xcoords = [] }, setDash: function (t, e) { this.current.dashArray = t, this.current.dashPhase = e }, constructPath: function (e, n) { var i = this.current, a = i.x, s = i.y; i.path = document.createElementNS(r, "svg:path"); for (var l = [], c = e.length, h = 0, u = 0; h < c; h++) switch (0 | e[h]) { case o.rectangle: a = n[u++], s = n[u++]; var d = a + n[u++], p = s + n[u++]; l.push("M", t(a), t(s), "L", t(d), t(s), "L", t(d), t(p), "L", t(a), t(p), "Z"); break; case o.moveTo: a = n[u++], s = n[u++], l.push("M", t(a), t(s)); break; case o.lineTo: a = n[u++], s = n[u++], l.push("L", t(a), t(s)); break; case o.curveTo: a = n[u + 4], s = n[u + 5], l.push("C", t(n[u]), t(n[u + 1]), t(n[u + 2]), t(n[u + 3]), t(a), t(s)), u += 6; break; case o.curveTo2: a = n[u + 2], s = n[u + 3], l.push("C", t(a), t(s), t(n[u]), t(n[u + 1]), t(n[u + 2]), t(n[u + 3])), u += 4; break; case o.curveTo3: a = n[u + 2], s = n[u + 3], l.push("C", t(n[u]), t(n[u + 1]), t(a), t(s), t(a), t(s)), u += 4; break; case o.closePath: l.push("Z") } i.path.setAttributeNS(null, "d", l.join(" ")), i.path.setAttributeNS(null, "stroke-miterlimit", t(i.miterLimit)), i.path.setAttributeNS(null, "stroke-linecap", i.lineCap), i.path.setAttributeNS(null, "stroke-linejoin", i.lineJoin), i.path.setAttributeNS(null, "stroke-width", t(i.lineWidth) + "px"), i.path.setAttributeNS(null, "stroke-dasharray", i.dashArray.map(t).join(" ")), i.path.setAttributeNS(null, "stroke-dashoffset", t(i.dashPhase) + "px"), i.path.setAttributeNS(null, "fill", "none"), this.tgrp.appendChild(i.path), i.pendingClip ? (this.cgrp.appendChild(this.tgrp), this.pgrp.appendChild(this.cgrp)) : this.pgrp.appendChild(this.tgrp), i.element = i.path, i.setCurrentPoint(a, s) }, endPath: function () { this.current.pendingClip ? (this.cgrp.appendChild(this.tgrp), this.pgrp.appendChild(this.cgrp)) : this.pgrp.appendChild(this.tgrp), this.tgrp = document.createElementNS(r, "svg:g"), this.tgrp.setAttributeNS(null, "transform", e(this.transformMatrix)) }, clip: function (t) { var n = this.current; n.clipId = "clippath" + h, h++, this.clippath = document.createElementNS(r, "svg:clipPath"), this.clippath.setAttributeNS(null, "id", n.clipId); var i = n.element.cloneNode(); "evenodd" === t ? i.setAttributeNS(null, "clip-rule", "evenodd") : i.setAttributeNS(null, "clip-rule", "nonzero"), this.clippath.setAttributeNS(null, "transform", e(this.transformMatrix)), this.clippath.appendChild(i), this.defs.appendChild(this.clippath), n.pendingClip = !0, this.cgrp = document.createElementNS(r, "svg:g"), this.cgrp.setAttributeNS(null, "clip-path", "url(#" + n.clipId + ")"), this.pgrp.appendChild(this.cgrp) }, closePath: function () { var t = this.current, e = t.path.getAttributeNS(null, "d"); e += "Z", t.path.setAttributeNS(null, "d", e) }, setLeading: function (t) { this.current.leading = -t }, setTextRise: function (t) { this.current.textRise = t }, setHScale: function (t) { this.current.textHScale = t / 100 }, setGState: function (t) { for (var e = 0, n = t.length; e < n; e++) { var i = t[e], r = i[0], a = i[1]; switch (r) { case "LW": this.setLineWidth(a); break; case "LC": this.setLineCap(a); break; case "LJ": this.setLineJoin(a); break; case "ML": this.setMiterLimit(a); break; case "D": this.setDash(a[0], a[1]); break; case "RI": case "FL": break; case "Font": this.setFont(a) } } }, fill: function () { var t = this.current; t.element.setAttributeNS(null, "fill", t.fillColor) }, stroke: function () { var t = this.current; t.element.setAttributeNS(null, "stroke", t.strokeColor), t.element.setAttributeNS(null, "fill", "none") }, eoFill: function () { var t = this.current; t.element.setAttributeNS(null, "fill", t.fillColor), t.element.setAttributeNS(null, "fill-rule", "evenodd") }, fillStroke: function () { this.stroke(), this.fill() }, eoFillStroke: function () { this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke() }, closeStroke: function () { this.closePath(), this.stroke() }, closeFillStroke: function () { this.closePath(), this.fillStroke() }, paintSolidColorImageMask: function () { var t = this.current, e = document.createElementNS(r, "svg:rect"); e.setAttributeNS(null, "x", "0"), e.setAttributeNS(null, "y", "0"), e.setAttributeNS(null, "width", "1px"), e.setAttributeNS(null, "height", "1px"), e.setAttributeNS(null, "fill", t.fillColor), this.tgrp.appendChild(e) }, paintJpegXObject: function (e, n, i) { var s = this.current, o = this.objs.get(e), l = document.createElementNS(r, "svg:image"); l.setAttributeNS(a, "xlink:href", o.src), l.setAttributeNS(null, "width", o.width + "px"), l.setAttributeNS(null, "height", o.height + "px"), l.setAttributeNS(null, "x", "0"), l.setAttributeNS(null, "y", t(-i)), l.setAttributeNS(null, "transform", "scale(" + t(1 / n) + " " + t(-1 / i) + ")"), this.tgrp.appendChild(l), s.pendingClip ? (this.cgrp.appendChild(this.tgrp), this.pgrp.appendChild(this.cgrp)) : this.pgrp.appendChild(this.tgrp) }, paintImageXObject: function (t) { var e = this.objs.get(t); e ? this.paintInlineImageXObject(e) : c("Dependent image isn't ready yet") }, paintInlineImageXObject: function (e, n) { var i = this.current, s = e.width, o = e.height, l = ct(e), c = document.createElementNS(r, "svg:rect"); c.setAttributeNS(null, "x", "0"), c.setAttributeNS(null, "y", "0"), c.setAttributeNS(null, "width", t(s)), c.setAttributeNS(null, "height", t(o)), i.element = c, this.clip("nonzero"); var h = document.createElementNS(r, "svg:image"); h.setAttributeNS(a, "xlink:href", l), h.setAttributeNS(null, "x", "0"), h.setAttributeNS(null, "y", t(-o)), h.setAttributeNS(null, "width", t(s) + "px"), h.setAttributeNS(null, "height", t(o) + "px"), h.setAttributeNS(null, "transform", "scale(" + t(1 / s) + " " + t(-1 / o) + ")"), n ? n.appendChild(h) : this.tgrp.appendChild(h), i.pendingClip ? (this.cgrp.appendChild(this.tgrp), this.pgrp.appendChild(this.cgrp)) : this.pgrp.appendChild(this.tgrp) }, paintImageMaskXObject: function (e) { var n = this.current, i = e.width, a = e.height, s = n.fillColor; n.maskId = "mask" + u++; var o = document.createElementNS(r, "svg:mask"); o.setAttributeNS(null, "id", n.maskId); var l = document.createElementNS(r, "svg:rect"); l.setAttributeNS(null, "x", "0"), l.setAttributeNS(null, "y", "0"), l.setAttributeNS(null, "width", t(i)), l.setAttributeNS(null, "height", t(a)), l.setAttributeNS(null, "fill", s), l.setAttributeNS(null, "mask", "url(#" + n.maskId + ")"), this.defs.appendChild(o), this.tgrp.appendChild(l), this.paintInlineImageXObject(e, o) }, paintFormXObjectBegin: function (e, n) { if (this.save(), E(e) && 6 === e.length && this.transform(e[0], e[1], e[2], e[3], e[4], e[5]), E(n) && 4 === n.length) { var i = n[2] - n[0], a = n[3] - n[1], s = document.createElementNS(r, "svg:rect"); s.setAttributeNS(null, "x", n[0]), s.setAttributeNS(null, "y", n[1]), s.setAttributeNS(null, "width", t(i)), s.setAttributeNS(null, "height", t(a)), this.current.element = s, this.clip("nonzero"), this.endPath() } }, paintFormXObjectEnd: function () { this.restore() } }, i }(); PDFJS.SVGGraphics = ut }.call("undefined" == typeof window ? this : window), PDFJS.workerSrc || "undefined" == typeof document || (PDFJS.workerSrc = function () { "use strict"; var t = document.currentScript.src; return t && t.replace(/\.js$/i, ".worker.js") }());